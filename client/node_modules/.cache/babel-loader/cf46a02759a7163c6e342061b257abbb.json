{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst common = require('./common');\n\nconst platform = require('os').platform();\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Constants\n */\n\n\nconst DEFAULT_DELAY = common.DEFAULT_DELAY;\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n/**\n * Export `NodeWatcher` class.\n * Watches `dir`.\n *\n * @class NodeWatcher\n * @param {String} dir\n * @param {Object} opts\n * @public\n */\n\nmodule.exports = class NodeWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n    common.assignOptions(this, opts);\n    this.watched = Object.create(null);\n    this.changeTimers = Object.create(null);\n    this.dirRegistery = Object.create(null);\n    this.root = path.resolve(dir);\n    this.watchdir = this.watchdir.bind(this);\n    this.register = this.register.bind(this);\n    this.checkedEmitError = this.checkedEmitError.bind(this);\n    this.watchdir(this.root);\n    common.recReaddir(this.root, this.watchdir, this.register, this.emit.bind(this, 'ready'), this.checkedEmitError, this.ignored);\n  }\n  /**\n   * Register files that matches our globs to know what to type of event to\n   * emit in the future.\n   *\n   * Registery looks like the following:\n   *\n   *  dirRegister => Map {\n   *    dirpath => Map {\n   *       filename => true\n   *    }\n   *  }\n   *\n   * @param {string} filepath\n   * @return {boolean} whether or not we have registered the file.\n   * @private\n   */\n\n\n  register(filepath) {\n    let relativePath = path.relative(this.root, filepath);\n\n    if (!common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n      return false;\n    }\n\n    let dir = path.dirname(filepath);\n\n    if (!this.dirRegistery[dir]) {\n      this.dirRegistery[dir] = Object.create(null);\n    }\n\n    let filename = path.basename(filepath);\n    this.dirRegistery[dir][filename] = true;\n    return true;\n  }\n  /**\n   * Removes a file from the registery.\n   *\n   * @param {string} filepath\n   * @private\n   */\n\n\n  unregister(filepath) {\n    let dir = path.dirname(filepath);\n\n    if (this.dirRegistery[dir]) {\n      let filename = path.basename(filepath);\n      delete this.dirRegistery[dir][filename];\n    }\n  }\n  /**\n   * Removes a dir from the registery.\n   *\n   * @param {string} dirpath\n   * @private\n   */\n\n\n  unregisterDir(dirpath) {\n    if (this.dirRegistery[dirpath]) {\n      delete this.dirRegistery[dirpath];\n    }\n  }\n  /**\n   * Checks if a file or directory exists in the registery.\n   *\n   * @param {string} fullpath\n   * @return {boolean}\n   * @private\n   */\n\n\n  registered(fullpath) {\n    let dir = path.dirname(fullpath);\n    return this.dirRegistery[fullpath] || this.dirRegistery[dir] && this.dirRegistery[dir][path.basename(fullpath)];\n  }\n  /**\n   * Emit \"error\" event if it's not an ignorable event\n   *\n   * @param error\n   * @private\n   */\n\n\n  checkedEmitError(error) {\n    if (!isIgnorableFileError(error)) {\n      this.emit('error', error);\n    }\n  }\n  /**\n   * Watch a directory.\n   *\n   * @param {string} dir\n   * @private\n   */\n\n\n  watchdir(dir) {\n    if (this.watched[dir]) {\n      return;\n    }\n\n    let watcher = fs.watch(dir, {\n      persistent: true\n    }, this.normalizeChange.bind(this, dir));\n    this.watched[dir] = watcher;\n    watcher.on('error', this.checkedEmitError);\n\n    if (this.root !== dir) {\n      this.register(dir);\n    }\n  }\n  /**\n   * Stop watching a directory.\n   *\n   * @param {string} dir\n   * @private\n   */\n\n\n  stopWatching(dir) {\n    if (this.watched[dir]) {\n      this.watched[dir].close();\n      delete this.watched[dir];\n    }\n  }\n  /**\n   * End watching.\n   *\n   * @public\n   */\n\n\n  close(callback) {\n    Object.keys(this.watched).forEach(this.stopWatching, this);\n    this.removeAllListeners();\n\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n  /**\n   * On some platforms, as pointed out on the fs docs (most likely just win32)\n   * the file argument might be missing from the fs event. Try to detect what\n   * change by detecting if something was deleted or the most recent file change.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n\n  detectChangedFile(dir, event, callback) {\n    if (!this.dirRegistery[dir]) {\n      return;\n    }\n\n    let found = false;\n    let closest = {\n      mtime: 0\n    };\n    let c = 0;\n    Object.keys(this.dirRegistery[dir]).forEach(function (file, i, arr) {\n      fs.lstat(path.join(dir, file), function (error, stat) {\n        if (found) {\n          return;\n        }\n\n        if (error) {\n          if (isIgnorableFileError(error)) {\n            found = true;\n            callback(file);\n          } else {\n            this.emit('error', error);\n          }\n        } else {\n          if (stat.mtime > closest.mtime) {\n            stat.file = file;\n            closest = stat;\n          }\n\n          if (arr.length === ++c) {\n            callback(closest.file);\n          }\n        }\n      }.bind(this));\n    }, this);\n  }\n  /**\n   * Normalize fs events and pass it on to be processed.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n\n  normalizeChange(dir, event, file) {\n    if (!file) {\n      this.detectChangedFile(dir, event, function (actualFile) {\n        if (actualFile) {\n          this.processChange(dir, event, actualFile);\n        }\n      }.bind(this));\n    } else {\n      this.processChange(dir, event, path.normalize(file));\n    }\n  }\n  /**\n   * Process changes.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n\n  processChange(dir, event, file) {\n    let fullPath = path.join(dir, file);\n    let relativePath = path.join(path.relative(this.root, dir), file);\n    fs.lstat(fullPath, function (error, stat) {\n      if (error && error.code !== 'ENOENT') {\n        this.emit('error', error);\n      } else if (!error && stat.isDirectory()) {\n        // win32 emits usless change events on dirs.\n        if (event !== 'change') {\n          this.watchdir(fullPath);\n\n          if (common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n            this.emitEvent(ADD_EVENT, relativePath, stat);\n          }\n        }\n      } else {\n        let registered = this.registered(fullPath);\n\n        if (error && error.code === 'ENOENT') {\n          this.unregister(fullPath);\n          this.stopWatching(fullPath);\n          this.unregisterDir(fullPath);\n\n          if (registered) {\n            this.emitEvent(DELETE_EVENT, relativePath);\n          }\n        } else if (registered) {\n          this.emitEvent(CHANGE_EVENT, relativePath, stat);\n        } else {\n          if (this.register(fullPath)) {\n            this.emitEvent(ADD_EVENT, relativePath, stat);\n          }\n        }\n      }\n    }.bind(this));\n  }\n  /**\n   * Triggers a 'change' event after debounding it to take care of duplicate\n   * events on os x.\n   *\n   * @private\n   */\n\n\n  emitEvent(type, file, stat) {\n    let key = type + '-' + file;\n    let addKey = ADD_EVENT + '-' + file;\n\n    if (type === CHANGE_EVENT && this.changeTimers[addKey]) {\n      // Ignore the change event that is immediately fired after an add event.\n      // (This happens on Linux).\n      return;\n    }\n\n    clearTimeout(this.changeTimers[key]);\n    this.changeTimers[key] = setTimeout(function () {\n      delete this.changeTimers[key];\n\n      if (type === ADD_EVENT && stat.isDirectory()) {\n        // Recursively emit add events and watch for sub-files/folders\n        common.recReaddir(path.resolve(this.root, file), function emitAddDir(dir, stats) {\n          this.watchdir(dir);\n          this.rawEmitEvent(ADD_EVENT, path.relative(this.root, dir), stats);\n        }.bind(this), function emitAddFile(file, stats) {\n          this.register(file);\n          this.rawEmitEvent(ADD_EVENT, path.relative(this.root, file), stats);\n        }.bind(this), function endCallback() {}, this.checkedEmitError, this.ignored);\n      } else {\n        this.rawEmitEvent(type, file, stat);\n      }\n    }.bind(this), DEFAULT_DELAY);\n  }\n  /**\n   * Actually emit the events\n   */\n\n\n  rawEmitEvent(type, file, stat) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n\n};\n/**\n * Determine if a given FS error can be ignored\n *\n * @private\n */\n\nfunction isIgnorableFileError(error) {\n  return error.code === 'ENOENT' || // Workaround Windows node issue #4337.\n  error.code === 'EPERM' && platform === 'win32';\n}","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/sane/src/node_watcher.js"],"names":["fs","require","path","common","platform","EventEmitter","DEFAULT_DELAY","CHANGE_EVENT","DELETE_EVENT","ADD_EVENT","ALL_EVENT","module","exports","NodeWatcher","constructor","dir","opts","assignOptions","watched","Object","create","changeTimers","dirRegistery","root","resolve","watchdir","bind","register","checkedEmitError","recReaddir","emit","ignored","filepath","relativePath","relative","isFileIncluded","globs","dot","doIgnore","dirname","filename","basename","unregister","unregisterDir","dirpath","registered","fullpath","error","isIgnorableFileError","watcher","watch","persistent","normalizeChange","on","stopWatching","close","callback","keys","forEach","removeAllListeners","setImmediate","detectChangedFile","event","found","closest","mtime","c","file","i","arr","lstat","join","stat","length","actualFile","processChange","normalize","fullPath","code","isDirectory","emitEvent","type","key","addKey","clearTimeout","setTimeout","emitAddDir","stats","rawEmitEvent","emitAddFile","endCallback"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst common = require('./common');\nconst platform = require('os').platform();\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Constants\n */\n\nconst DEFAULT_DELAY = common.DEFAULT_DELAY;\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n\n/**\n * Export `NodeWatcher` class.\n * Watches `dir`.\n *\n * @class NodeWatcher\n * @param {String} dir\n * @param {Object} opts\n * @public\n */\n\nmodule.exports = class NodeWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n\n    common.assignOptions(this, opts);\n\n    this.watched = Object.create(null);\n    this.changeTimers = Object.create(null);\n    this.dirRegistery = Object.create(null);\n    this.root = path.resolve(dir);\n    this.watchdir = this.watchdir.bind(this);\n    this.register = this.register.bind(this);\n    this.checkedEmitError = this.checkedEmitError.bind(this);\n\n    this.watchdir(this.root);\n    common.recReaddir(\n      this.root,\n      this.watchdir,\n      this.register,\n      this.emit.bind(this, 'ready'),\n      this.checkedEmitError,\n      this.ignored\n    );\n  }\n\n  /**\n   * Register files that matches our globs to know what to type of event to\n   * emit in the future.\n   *\n   * Registery looks like the following:\n   *\n   *  dirRegister => Map {\n   *    dirpath => Map {\n   *       filename => true\n   *    }\n   *  }\n   *\n   * @param {string} filepath\n   * @return {boolean} whether or not we have registered the file.\n   * @private\n   */\n\n  register(filepath) {\n    let relativePath = path.relative(this.root, filepath);\n    if (\n      !common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)\n    ) {\n      return false;\n    }\n\n    let dir = path.dirname(filepath);\n    if (!this.dirRegistery[dir]) {\n      this.dirRegistery[dir] = Object.create(null);\n    }\n\n    let filename = path.basename(filepath);\n    this.dirRegistery[dir][filename] = true;\n\n    return true;\n  }\n\n  /**\n   * Removes a file from the registery.\n   *\n   * @param {string} filepath\n   * @private\n   */\n\n  unregister(filepath) {\n    let dir = path.dirname(filepath);\n    if (this.dirRegistery[dir]) {\n      let filename = path.basename(filepath);\n      delete this.dirRegistery[dir][filename];\n    }\n  }\n\n  /**\n   * Removes a dir from the registery.\n   *\n   * @param {string} dirpath\n   * @private\n   */\n\n  unregisterDir(dirpath) {\n    if (this.dirRegistery[dirpath]) {\n      delete this.dirRegistery[dirpath];\n    }\n  }\n\n  /**\n   * Checks if a file or directory exists in the registery.\n   *\n   * @param {string} fullpath\n   * @return {boolean}\n   * @private\n   */\n\n  registered(fullpath) {\n    let dir = path.dirname(fullpath);\n    return (\n      this.dirRegistery[fullpath] ||\n      (this.dirRegistery[dir] &&\n        this.dirRegistery[dir][path.basename(fullpath)])\n    );\n  }\n\n  /**\n   * Emit \"error\" event if it's not an ignorable event\n   *\n   * @param error\n   * @private\n   */\n  checkedEmitError(error) {\n    if (!isIgnorableFileError(error)) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Watch a directory.\n   *\n   * @param {string} dir\n   * @private\n   */\n\n  watchdir(dir) {\n    if (this.watched[dir]) {\n      return;\n    }\n\n    let watcher = fs.watch(\n      dir,\n      { persistent: true },\n      this.normalizeChange.bind(this, dir)\n    );\n    this.watched[dir] = watcher;\n\n    watcher.on('error', this.checkedEmitError);\n\n    if (this.root !== dir) {\n      this.register(dir);\n    }\n  }\n\n  /**\n   * Stop watching a directory.\n   *\n   * @param {string} dir\n   * @private\n   */\n\n  stopWatching(dir) {\n    if (this.watched[dir]) {\n      this.watched[dir].close();\n      delete this.watched[dir];\n    }\n  }\n\n  /**\n   * End watching.\n   *\n   * @public\n   */\n\n  close(callback) {\n    Object.keys(this.watched).forEach(this.stopWatching, this);\n    this.removeAllListeners();\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n\n  /**\n   * On some platforms, as pointed out on the fs docs (most likely just win32)\n   * the file argument might be missing from the fs event. Try to detect what\n   * change by detecting if something was deleted or the most recent file change.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n  detectChangedFile(dir, event, callback) {\n    if (!this.dirRegistery[dir]) {\n      return;\n    }\n\n    let found = false;\n    let closest = { mtime: 0 };\n    let c = 0;\n    Object.keys(this.dirRegistery[dir]).forEach(function(file, i, arr) {\n      fs.lstat(\n        path.join(dir, file),\n        function(error, stat) {\n          if (found) {\n            return;\n          }\n\n          if (error) {\n            if (isIgnorableFileError(error)) {\n              found = true;\n              callback(file);\n            } else {\n              this.emit('error', error);\n            }\n          } else {\n            if (stat.mtime > closest.mtime) {\n              stat.file = file;\n              closest = stat;\n            }\n            if (arr.length === ++c) {\n              callback(closest.file);\n            }\n          }\n        }.bind(this)\n      );\n    }, this);\n  }\n\n  /**\n   * Normalize fs events and pass it on to be processed.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n  normalizeChange(dir, event, file) {\n    if (!file) {\n      this.detectChangedFile(\n        dir,\n        event,\n        function(actualFile) {\n          if (actualFile) {\n            this.processChange(dir, event, actualFile);\n          }\n        }.bind(this)\n      );\n    } else {\n      this.processChange(dir, event, path.normalize(file));\n    }\n  }\n\n  /**\n   * Process changes.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n  processChange(dir, event, file) {\n    let fullPath = path.join(dir, file);\n    let relativePath = path.join(path.relative(this.root, dir), file);\n\n    fs.lstat(\n      fullPath,\n      function(error, stat) {\n        if (error && error.code !== 'ENOENT') {\n          this.emit('error', error);\n        } else if (!error && stat.isDirectory()) {\n          // win32 emits usless change events on dirs.\n          if (event !== 'change') {\n            this.watchdir(fullPath);\n            if (\n              common.isFileIncluded(\n                this.globs,\n                this.dot,\n                this.doIgnore,\n                relativePath\n              )\n            ) {\n              this.emitEvent(ADD_EVENT, relativePath, stat);\n            }\n          }\n        } else {\n          let registered = this.registered(fullPath);\n          if (error && error.code === 'ENOENT') {\n            this.unregister(fullPath);\n            this.stopWatching(fullPath);\n            this.unregisterDir(fullPath);\n            if (registered) {\n              this.emitEvent(DELETE_EVENT, relativePath);\n            }\n          } else if (registered) {\n            this.emitEvent(CHANGE_EVENT, relativePath, stat);\n          } else {\n            if (this.register(fullPath)) {\n              this.emitEvent(ADD_EVENT, relativePath, stat);\n            }\n          }\n        }\n      }.bind(this)\n    );\n  }\n\n  /**\n   * Triggers a 'change' event after debounding it to take care of duplicate\n   * events on os x.\n   *\n   * @private\n   */\n\n  emitEvent(type, file, stat) {\n    let key = type + '-' + file;\n    let addKey = ADD_EVENT + '-' + file;\n    if (type === CHANGE_EVENT && this.changeTimers[addKey]) {\n      // Ignore the change event that is immediately fired after an add event.\n      // (This happens on Linux).\n      return;\n    }\n    clearTimeout(this.changeTimers[key]);\n    this.changeTimers[key] = setTimeout(\n      function() {\n        delete this.changeTimers[key];\n        if (type === ADD_EVENT && stat.isDirectory()) {\n          // Recursively emit add events and watch for sub-files/folders\n          common.recReaddir(\n            path.resolve(this.root, file),\n            function emitAddDir(dir, stats) {\n              this.watchdir(dir);\n              this.rawEmitEvent(\n                ADD_EVENT,\n                path.relative(this.root, dir),\n                stats\n              );\n            }.bind(this),\n            function emitAddFile(file, stats) {\n              this.register(file);\n              this.rawEmitEvent(\n                ADD_EVENT,\n                path.relative(this.root, file),\n                stats\n              );\n            }.bind(this),\n            function endCallback() {},\n            this.checkedEmitError,\n            this.ignored\n          );\n        } else {\n          this.rawEmitEvent(type, file, stat);\n        }\n      }.bind(this),\n      DEFAULT_DELAY\n    );\n  }\n\n  /**\n   * Actually emit the events\n   */\n  rawEmitEvent(type, file, stat) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n};\n/**\n * Determine if a given FS error can be ignored\n *\n * @private\n */\nfunction isIgnorableFileError(error) {\n  return (\n    error.code === 'ENOENT' ||\n    // Workaround Windows node issue #4337.\n    (error.code === 'EPERM' && platform === 'win32')\n  );\n}\n"]},"metadata":{},"sourceType":"script"}