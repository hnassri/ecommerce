{"ast":null,"code":"'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _constants() {\n  const data = _interopRequireDefault(require('../constants'));\n\n  _constants = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fastPath() {\n  const data = _interopRequireWildcard(require('../lib/fast_path'));\n\n  fastPath = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _normalizePathSep() {\n  const data = _interopRequireDefault(require('../lib/normalizePathSep'));\n\n  _normalizePathSep = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting';\n\nfunction WatchmanError(error) {\n  error.message = `Watchman error: ${error.message.trim()}. Make sure watchman ` + `is running for this project. See ${watchmanURL}.`;\n  return error;\n}\n\nmodule.exports = async function watchmanCrawl(options) {\n  const fields = ['name', 'exists', 'mtime_ms', 'size'];\n  const {\n    data,\n    extensions,\n    ignore,\n    rootDir,\n    roots\n  } = options;\n  const defaultWatchExpression = ['allof', ['type', 'f'], ['anyof', ...extensions.map(extension => ['suffix', extension])]];\n  const clocks = data.clocks;\n  const client = new (_fbWatchman().default.Client)();\n  let clientError;\n  client.on('error', error => clientError = WatchmanError(error)); // TODO: type better than `any`\n\n  const cmd = (...args) => new Promise((resolve, reject) => client.command(args, (error, result) => error ? reject(WatchmanError(error)) : resolve(result)));\n\n  if (options.computeSha1) {\n    const {\n      capabilities\n    } = await cmd('list-capabilities');\n\n    if (capabilities.indexOf('field-content.sha1hex') !== -1) {\n      fields.push('content.sha1hex');\n    }\n  }\n\n  async function getWatchmanRoots(roots) {\n    const watchmanRoots = new Map();\n    await Promise.all(roots.map(async root => {\n      const response = await cmd('watch-project', root);\n      const existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a\n      // relative_path before.\n\n      const canBeFiltered = !existing || existing.length > 0;\n\n      if (canBeFiltered) {\n        if (response.relative_path) {\n          watchmanRoots.set(response.watch, (existing || []).concat(response.relative_path));\n        } else {\n          // Make the filter directories an empty array to signal that this\n          // root was already seen and needs to be watched for all files or\n          // directories.\n          watchmanRoots.set(response.watch, []);\n        }\n      }\n    }));\n    return watchmanRoots;\n  }\n\n  async function queryWatchmanForDirs(rootProjectDirMappings) {\n    const files = new Map();\n    let isFresh = false;\n    await Promise.all(Array.from(rootProjectDirMappings).map(async ([root, directoryFilters]) => {\n      const expression = Array.from(defaultWatchExpression);\n      const glob = [];\n\n      if (directoryFilters.length > 0) {\n        expression.push(['anyof', ...directoryFilters.map(dir => ['dirname', dir])]);\n\n        for (const directory of directoryFilters) {\n          for (const extension of extensions) {\n            glob.push(`${directory}/**/*.${extension}`);\n          }\n        }\n      } else {\n        for (const extension of extensions) {\n          glob.push(`**/*.${extension}`);\n        }\n      }\n\n      const relativeRoot = fastPath().relative(rootDir, root);\n      const query = clocks.has(relativeRoot) // Use the `since` generator if we have a clock available\n      ? {\n        expression,\n        fields,\n        since: clocks.get(relativeRoot)\n      } // Otherwise use the `glob` filter\n      : {\n        expression,\n        fields,\n        glob,\n        glob_includedotfiles: true\n      };\n      const response = await cmd('query', root, query);\n\n      if ('warning' in response) {\n        console.warn('watchman warning: ', response.warning);\n      }\n\n      isFresh = isFresh || response.is_fresh_instance;\n      files.set(root, response);\n    }));\n    return {\n      files,\n      isFresh\n    };\n  }\n\n  let files = data.files;\n  let removedFiles = new Map();\n  const changedFiles = new Map();\n  let watchmanFiles;\n  let isFresh = false;\n\n  try {\n    const watchmanRoots = await getWatchmanRoots(roots);\n    const watchmanFileResults = await queryWatchmanForDirs(watchmanRoots); // Reset the file map if watchman was restarted and sends us a list of\n    // files.\n\n    if (watchmanFileResults.isFresh) {\n      files = new Map();\n      removedFiles = new Map(data.files);\n      isFresh = true;\n    }\n\n    watchmanFiles = watchmanFileResults.files;\n  } finally {\n    client.end();\n  }\n\n  if (clientError) {\n    throw clientError;\n  } // TODO: remove non-null\n\n\n  for (const [watchRoot, response] of watchmanFiles) {\n    const fsRoot = (0, _normalizePathSep().default)(watchRoot);\n    const relativeFsRoot = fastPath().relative(rootDir, fsRoot);\n    clocks.set(relativeFsRoot, response.clock);\n\n    for (const fileData of response.files) {\n      const filePath = fsRoot + path().sep + (0, _normalizePathSep().default)(fileData.name);\n      const relativeFilePath = fastPath().relative(rootDir, filePath);\n      const existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files\n      // and we remove them as we verify they still exist.\n\n      if (isFresh && existingFileData && fileData.exists) {\n        removedFiles.delete(relativeFilePath);\n      }\n\n      if (!fileData.exists) {\n        // No need to act on files that do not exist and were not tracked.\n        if (existingFileData) {\n          files.delete(relativeFilePath); // If watchman is not fresh, we will know what specific files were\n          // deleted since we last ran and can track only those files.\n\n          if (!isFresh) {\n            removedFiles.set(relativeFilePath, existingFileData);\n          }\n        }\n      } else if (!ignore(filePath)) {\n        const mtime = typeof fileData.mtime_ms === 'number' ? fileData.mtime_ms : fileData.mtime_ms.toNumber();\n        const size = fileData.size;\n        let sha1hex = fileData['content.sha1hex'];\n\n        if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n          sha1hex = null;\n        }\n\n        let nextData;\n\n        if (existingFileData && existingFileData[_constants().default.MTIME] === mtime) {\n          nextData = existingFileData;\n        } else if (existingFileData && sha1hex && existingFileData[_constants().default.SHA1] === sha1hex) {\n          nextData = [existingFileData[0], mtime, existingFileData[2], existingFileData[3], existingFileData[4], existingFileData[5]];\n        } else {\n          // See ../constants.ts\n          nextData = ['', mtime, size, 0, '', sha1hex];\n        }\n\n        files.set(relativeFilePath, nextData);\n        changedFiles.set(relativeFilePath, nextData);\n      }\n    }\n  }\n\n  data.files = files;\n  return {\n    changedFiles: isFresh ? undefined : changedFiles,\n    hasteMap: data,\n    removedFiles\n  };\n};","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/jest-haste-map/build/crawlers/watchman.js"],"names":["path","data","_interopRequireWildcard","require","_fbWatchman","_interopRequireDefault","_constants","fastPath","_normalizePathSep","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","watchmanURL","WatchmanError","error","message","trim","module","exports","watchmanCrawl","options","fields","extensions","ignore","rootDir","roots","defaultWatchExpression","map","extension","clocks","client","Client","clientError","on","cmd","args","Promise","resolve","reject","command","result","computeSha1","capabilities","indexOf","push","getWatchmanRoots","watchmanRoots","Map","all","root","response","existing","watch","canBeFiltered","length","relative_path","concat","queryWatchmanForDirs","rootProjectDirMappings","files","isFresh","Array","from","directoryFilters","expression","glob","dir","directory","relativeRoot","relative","query","since","glob_includedotfiles","console","warn","warning","is_fresh_instance","removedFiles","changedFiles","watchmanFiles","watchmanFileResults","end","watchRoot","fsRoot","relativeFsRoot","clock","fileData","filePath","sep","name","relativeFilePath","existingFileData","exists","delete","mtime","mtime_ms","toNumber","size","sha1hex","nextData","MTIME","SHA1","undefined","hasteMap"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _constants() {\n  const data = _interopRequireDefault(require('../constants'));\n\n  _constants = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fastPath() {\n  const data = _interopRequireWildcard(require('../lib/fast_path'));\n\n  fastPath = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _normalizePathSep() {\n  const data = _interopRequireDefault(require('../lib/normalizePathSep'));\n\n  _normalizePathSep = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting';\n\nfunction WatchmanError(error) {\n  error.message =\n    `Watchman error: ${error.message.trim()}. Make sure watchman ` +\n    `is running for this project. See ${watchmanURL}.`;\n  return error;\n}\n\nmodule.exports = async function watchmanCrawl(options) {\n  const fields = ['name', 'exists', 'mtime_ms', 'size'];\n  const {data, extensions, ignore, rootDir, roots} = options;\n  const defaultWatchExpression = [\n    'allof',\n    ['type', 'f'],\n    ['anyof', ...extensions.map(extension => ['suffix', extension])]\n  ];\n  const clocks = data.clocks;\n  const client = new (_fbWatchman().default.Client)();\n  let clientError;\n  client.on('error', error => (clientError = WatchmanError(error))); // TODO: type better than `any`\n\n  const cmd = (...args) =>\n    new Promise((resolve, reject) =>\n      client.command(args, (error, result) =>\n        error ? reject(WatchmanError(error)) : resolve(result)\n      )\n    );\n\n  if (options.computeSha1) {\n    const {capabilities} = await cmd('list-capabilities');\n\n    if (capabilities.indexOf('field-content.sha1hex') !== -1) {\n      fields.push('content.sha1hex');\n    }\n  }\n\n  async function getWatchmanRoots(roots) {\n    const watchmanRoots = new Map();\n    await Promise.all(\n      roots.map(async root => {\n        const response = await cmd('watch-project', root);\n        const existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a\n        // relative_path before.\n\n        const canBeFiltered = !existing || existing.length > 0;\n\n        if (canBeFiltered) {\n          if (response.relative_path) {\n            watchmanRoots.set(\n              response.watch,\n              (existing || []).concat(response.relative_path)\n            );\n          } else {\n            // Make the filter directories an empty array to signal that this\n            // root was already seen and needs to be watched for all files or\n            // directories.\n            watchmanRoots.set(response.watch, []);\n          }\n        }\n      })\n    );\n    return watchmanRoots;\n  }\n\n  async function queryWatchmanForDirs(rootProjectDirMappings) {\n    const files = new Map();\n    let isFresh = false;\n    await Promise.all(\n      Array.from(rootProjectDirMappings).map(\n        async ([root, directoryFilters]) => {\n          const expression = Array.from(defaultWatchExpression);\n          const glob = [];\n\n          if (directoryFilters.length > 0) {\n            expression.push([\n              'anyof',\n              ...directoryFilters.map(dir => ['dirname', dir])\n            ]);\n\n            for (const directory of directoryFilters) {\n              for (const extension of extensions) {\n                glob.push(`${directory}/**/*.${extension}`);\n              }\n            }\n          } else {\n            for (const extension of extensions) {\n              glob.push(`**/*.${extension}`);\n            }\n          }\n\n          const relativeRoot = fastPath().relative(rootDir, root);\n          const query = clocks.has(relativeRoot) // Use the `since` generator if we have a clock available\n            ? {\n                expression,\n                fields,\n                since: clocks.get(relativeRoot)\n              } // Otherwise use the `glob` filter\n            : {\n                expression,\n                fields,\n                glob,\n                glob_includedotfiles: true\n              };\n          const response = await cmd('query', root, query);\n\n          if ('warning' in response) {\n            console.warn('watchman warning: ', response.warning);\n          }\n\n          isFresh = isFresh || response.is_fresh_instance;\n          files.set(root, response);\n        }\n      )\n    );\n    return {\n      files,\n      isFresh\n    };\n  }\n\n  let files = data.files;\n  let removedFiles = new Map();\n  const changedFiles = new Map();\n  let watchmanFiles;\n  let isFresh = false;\n\n  try {\n    const watchmanRoots = await getWatchmanRoots(roots);\n    const watchmanFileResults = await queryWatchmanForDirs(watchmanRoots); // Reset the file map if watchman was restarted and sends us a list of\n    // files.\n\n    if (watchmanFileResults.isFresh) {\n      files = new Map();\n      removedFiles = new Map(data.files);\n      isFresh = true;\n    }\n\n    watchmanFiles = watchmanFileResults.files;\n  } finally {\n    client.end();\n  }\n\n  if (clientError) {\n    throw clientError;\n  } // TODO: remove non-null\n\n  for (const [watchRoot, response] of watchmanFiles) {\n    const fsRoot = (0, _normalizePathSep().default)(watchRoot);\n    const relativeFsRoot = fastPath().relative(rootDir, fsRoot);\n    clocks.set(relativeFsRoot, response.clock);\n\n    for (const fileData of response.files) {\n      const filePath =\n        fsRoot + path().sep + (0, _normalizePathSep().default)(fileData.name);\n      const relativeFilePath = fastPath().relative(rootDir, filePath);\n      const existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files\n      // and we remove them as we verify they still exist.\n\n      if (isFresh && existingFileData && fileData.exists) {\n        removedFiles.delete(relativeFilePath);\n      }\n\n      if (!fileData.exists) {\n        // No need to act on files that do not exist and were not tracked.\n        if (existingFileData) {\n          files.delete(relativeFilePath); // If watchman is not fresh, we will know what specific files were\n          // deleted since we last ran and can track only those files.\n\n          if (!isFresh) {\n            removedFiles.set(relativeFilePath, existingFileData);\n          }\n        }\n      } else if (!ignore(filePath)) {\n        const mtime =\n          typeof fileData.mtime_ms === 'number'\n            ? fileData.mtime_ms\n            : fileData.mtime_ms.toNumber();\n        const size = fileData.size;\n        let sha1hex = fileData['content.sha1hex'];\n\n        if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n          sha1hex = null;\n        }\n\n        let nextData;\n\n        if (\n          existingFileData &&\n          existingFileData[_constants().default.MTIME] === mtime\n        ) {\n          nextData = existingFileData;\n        } else if (\n          existingFileData &&\n          sha1hex &&\n          existingFileData[_constants().default.SHA1] === sha1hex\n        ) {\n          nextData = [\n            existingFileData[0],\n            mtime,\n            existingFileData[2],\n            existingFileData[3],\n            existingFileData[4],\n            existingFileData[5]\n          ];\n        } else {\n          // See ../constants.ts\n          nextData = ['', mtime, size, 0, '', sha1hex];\n        }\n\n        files.set(relativeFilePath, nextData);\n        changedFiles.set(relativeFilePath, nextData);\n      }\n    }\n  }\n\n  data.files = files;\n  return {\n    changedFiles: isFresh ? undefined : changedFiles,\n    hasteMap: data,\n    removedFiles\n  };\n};\n"]},"metadata":{},"sourceType":"script"}