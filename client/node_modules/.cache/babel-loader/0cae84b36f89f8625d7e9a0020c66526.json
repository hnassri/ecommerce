{"ast":null,"code":"//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n// Useful masks and values for bit twiddling\nvar MASK31 = 0x7fffffff,\n    VAL31 = 0x80000000;\nvar MASK32 = 0xffffffff,\n    VAL32 = 0x100000000; // Map for converting hex octets to strings\n\nvar _HEX = [];\n\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n} //\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\n\n\nvar Int64 = module.exports = function (a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n}; // Max integer value that JS can accurately represent\n\n\nInt64.MAX_INT = Math.pow(2, 53); // Min integer value that JS can accurately represent\n\nInt64.MIN_INT = -Math.pow(2, 53);\nInt64.prototype = {\n  constructor: Int64,\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function () {\n    var b = this.buffer,\n        o = this.offset,\n        carry = 1;\n\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function (hi, lo) {\n    var negate = false;\n\n    if (arguments.length == 1) {\n      if (typeof hi == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof hi == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    } // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n    // Copy bytes to buffer\n\n\n    var b = this.buffer,\n        o = this.offset;\n\n    for (var i = 7; i >= 0; i--) {\n      b[o + i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    } // Restore sign of passed argument\n\n\n    if (negate) this._2scomp();\n  },\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function (allowImprecise) {\n    var b = this.buffer,\n        o = this.offset; // Running sum of octets, doing a 2's complement\n\n    var negate = b[o] & 0x80,\n        x = 0,\n        carry = 1;\n\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o + i]; // 2's complement for negative numbers\n\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    } // Return Infinity if we've lost integer precision\n\n\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  },\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function () {\n    return this.toNumber(false);\n  },\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function (radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function (sep) {\n    var out = new Array(8);\n    var b = this.buffer,\n        o = this.offset;\n\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o + i]];\n    }\n\n    return out.join(sep || '');\n  },\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function (rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function (targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function (other) {\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    } // otherwise, compare bytes lexicographically\n\n\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset + i] !== other.buffer[other.offset + i]) {\n        return this.buffer[this.offset + i] - other.buffer[other.offset + i];\n      }\n    }\n\n    return 0;\n  },\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function (other) {\n    return this.compare(other) === 0;\n  },\n\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function () {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/node-int64/Int64.js"],"names":["MASK31","VAL31","MASK32","VAL32","_HEX","i","toString","Int64","module","exports","a1","a2","Buffer","buffer","offset","Object","prototype","call","setValue","apply","arguments","MAX_INT","Math","pow","MIN_INT","constructor","_2scomp","b","o","carry","v","hi","lo","negate","length","abs","RangeError","replace","substr","parseInt","Error","toNumber","allowImprecise","x","m","Infinity","valueOf","radix","toOctetString","sep","out","Array","join","toBuffer","rawBuffer","copy","targetBuffer","targetOffset","compare","other","equals","inspect"],"mappings":"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","sourcesContent":["//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n// Useful masks and values for bit twiddling\nvar MASK31 =  0x7fffffff, VAL31 = 0x80000000;\nvar MASK32 =  0xffffffff, VAL32 = 0x100000000;\n\n// Map for converting hex octets to strings\nvar _HEX = [];\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n}\n\n//\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\nvar Int64 = module.exports = function(a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n};\n\n\n// Max integer value that JS can accurately represent\nInt64.MAX_INT = Math.pow(2, 53);\n\n// Min integer value that JS can accurately represent\nInt64.MIN_INT = -Math.pow(2, 53);\n\nInt64.prototype = {\n\n  constructor: Int64,\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function() {\n    var b = this.buffer, o = this.offset, carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function(hi, lo) {\n    var negate = false;\n    if (arguments.length == 1) {\n      if (typeof(hi) == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof(hi) == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer, o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o+i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  },\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function(allowImprecise) {\n    var b = this.buffer, o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80, x = 0, carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o+i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  },\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function() {\n    return this.toNumber(false);\n  },\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function(radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function(sep) {\n    var out = new Array(8);\n    var b = this.buffer, o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o+i]];\n    }\n    return out.join(sep || '');\n  },\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function(rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function(targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function(other) {\n\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {\n        return this.buffer[this.offset+i] - other.buffer[other.offset+i];\n      }\n    }\n    return 0;\n  },\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function(other) {\n    return this.compare(other) === 0;\n  },\n\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function() {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};\n"]},"metadata":{},"sourceType":"script"}