{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst watch = require('@cnakazawa/watch');\n\nconst common = require('./common');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Constants\n */\n\n\nconst DEFAULT_DELAY = common.DEFAULT_DELAY;\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n/**\n * Export `PollWatcher` class.\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nmodule.exports = class PollWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n    opts = common.assignOptions(this, opts);\n    this.watched = Object.create(null);\n    this.root = path.resolve(dir);\n    watch.createMonitor(this.root, {\n      interval: (opts.interval || DEFAULT_DELAY) / 1000,\n      filter: this.filter.bind(this)\n    }, this.init.bind(this));\n  }\n  /**\n   * Given a fullpath of a file or directory check if we need to watch it.\n   *\n   * @param {string} filepath\n   * @param {object} stat\n   * @private\n   */\n\n\n  filter(filepath, stat) {\n    return stat.isDirectory() || common.isFileIncluded(this.globs, this.dot, this.doIgnore, path.relative(this.root, filepath));\n  }\n  /**\n   * Initiate the polling file watcher with the event emitter passed from\n   * `watch.watchTree`.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n\n  init(monitor) {\n    this.watched = monitor.files;\n    monitor.on('changed', this.emitEvent.bind(this, CHANGE_EVENT));\n    monitor.on('removed', this.emitEvent.bind(this, DELETE_EVENT));\n    monitor.on('created', this.emitEvent.bind(this, ADD_EVENT)); // 1 second wait because mtime is second-based.\n\n    setTimeout(this.emit.bind(this, 'ready'), 1000);\n  }\n  /**\n   * Transform and emit an event comming from the poller.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n\n  emitEvent(type, file, stat) {\n    file = path.relative(this.root, file);\n\n    if (type === DELETE_EVENT) {\n      // Matching the non-polling API\n      stat = null;\n    }\n\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n  /**\n   * End watching.\n   *\n   * @public\n   */\n\n\n  close(callback) {\n    Object.keys(this.watched).forEach(filepath => fs.unwatchFile(filepath));\n    this.removeAllListeners();\n\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n\n};","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/sane/src/poll_watcher.js"],"names":["fs","require","path","watch","common","EventEmitter","DEFAULT_DELAY","CHANGE_EVENT","DELETE_EVENT","ADD_EVENT","ALL_EVENT","module","exports","PollWatcher","constructor","dir","opts","assignOptions","watched","Object","create","root","resolve","createMonitor","interval","filter","bind","init","filepath","stat","isDirectory","isFileIncluded","globs","dot","doIgnore","relative","monitor","files","on","emitEvent","setTimeout","emit","type","file","close","callback","keys","forEach","unwatchFile","removeAllListeners","setImmediate"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst watch = require('@cnakazawa/watch');\nconst common = require('./common');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Constants\n */\n\nconst DEFAULT_DELAY = common.DEFAULT_DELAY;\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n\n/**\n * Export `PollWatcher` class.\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nmodule.exports = class PollWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n\n    opts = common.assignOptions(this, opts);\n\n    this.watched = Object.create(null);\n    this.root = path.resolve(dir);\n\n    watch.createMonitor(\n      this.root,\n      {\n        interval: (opts.interval || DEFAULT_DELAY) / 1000,\n        filter: this.filter.bind(this),\n      },\n      this.init.bind(this)\n    );\n  }\n\n  /**\n   * Given a fullpath of a file or directory check if we need to watch it.\n   *\n   * @param {string} filepath\n   * @param {object} stat\n   * @private\n   */\n\n  filter(filepath, stat) {\n    return (\n      stat.isDirectory() ||\n      common.isFileIncluded(\n        this.globs,\n        this.dot,\n        this.doIgnore,\n        path.relative(this.root, filepath)\n      )\n    );\n  }\n\n  /**\n   * Initiate the polling file watcher with the event emitter passed from\n   * `watch.watchTree`.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n  init(monitor) {\n    this.watched = monitor.files;\n    monitor.on('changed', this.emitEvent.bind(this, CHANGE_EVENT));\n    monitor.on('removed', this.emitEvent.bind(this, DELETE_EVENT));\n    monitor.on('created', this.emitEvent.bind(this, ADD_EVENT));\n    // 1 second wait because mtime is second-based.\n    setTimeout(this.emit.bind(this, 'ready'), 1000);\n  }\n\n  /**\n   * Transform and emit an event comming from the poller.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n  emitEvent(type, file, stat) {\n    file = path.relative(this.root, file);\n\n    if (type === DELETE_EVENT) {\n      // Matching the non-polling API\n      stat = null;\n    }\n\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n\n  /**\n   * End watching.\n   *\n   * @public\n   */\n\n  close(callback) {\n    Object.keys(this.watched).forEach(filepath => fs.unwatchFile(filepath));\n    this.removeAllListeners();\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}