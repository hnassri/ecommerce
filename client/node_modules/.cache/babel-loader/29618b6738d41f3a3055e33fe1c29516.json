{"ast":null,"code":"'use strict';\n\nconst execa = require('execa');\n\nconst {\n  statSync\n} = require('fs');\n\nconst path = require('path');\n\nconst common = require('./common');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst {\n  EOL\n} = require('os');\n/**\n * Constants\n */\n\n\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\nconst typeMap = {\n  rename: CHANGE_EVENT,\n  write: CHANGE_EVENT,\n  remove: DELETE_EVENT,\n  create: ADD_EVENT\n};\nconst messageRegexp = /(rename|write|remove|create)\\s(.+)/;\n/**\n * Manages streams from subprocess and turns into sane events\n *\n * @param {Stream} data\n * @private\n */\n\nfunction _messageHandler(data) {\n  data.toString().split(EOL).filter(str => str.trim().length).filter(str => messageRegexp.test(str)).map(line => {\n    const [, command, path] = [...line.match(messageRegexp)];\n    return [command, path];\n  }).forEach(([command, file]) => {\n    let stat;\n    const type = typeMap[command];\n\n    if (type === DELETE_EVENT) {\n      stat = null;\n    } else {\n      try {\n        stat = statSync(file);\n      } catch (e) {\n        // There is likely a delete coming down the pipe.\n        if (e.code === 'ENOENT') {\n          return;\n        }\n\n        throw e;\n      }\n    }\n\n    this.emitEvent(type, path.relative(this.root, file), stat);\n  });\n}\n/**\n * Export `WatchexecWatcher` class.\n * Watches `dir`.\n *\n * @class WatchexecWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\n\nclass WatchexecWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n    common.assignOptions(this, opts);\n    this.root = path.resolve(dir);\n    this._process = execa('watchexec', ['-n', '--', 'node', __dirname + '/watchexec_client.js'], {\n      cwd: dir\n    });\n\n    this._process.stdout.on('data', _messageHandler.bind(this));\n\n    this._readyTimer = setTimeout(this.emit.bind(this, 'ready'), 1000);\n  }\n\n  close(callback) {\n    clearTimeout(this._readyTimer);\n    this.removeAllListeners();\n    this._process && !this._process.killed && this._process.kill();\n\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n  /**\n   * Transform and emit an event comming from the poller.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n\n  emitEvent(type, file, stat) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n\n}\n\nWatchexecWatcher._messageHandler = _messageHandler;\nmodule.exports = WatchexecWatcher;","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/sane/src/watchexec_watcher.js"],"names":["execa","require","statSync","path","common","EventEmitter","EOL","CHANGE_EVENT","DELETE_EVENT","ADD_EVENT","ALL_EVENT","typeMap","rename","write","remove","create","messageRegexp","_messageHandler","data","toString","split","filter","str","trim","length","test","map","line","command","match","forEach","file","stat","type","e","code","emitEvent","relative","root","WatchexecWatcher","constructor","dir","opts","assignOptions","resolve","_process","__dirname","cwd","stdout","on","bind","_readyTimer","setTimeout","emit","close","callback","clearTimeout","removeAllListeners","killed","kill","setImmediate","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst execa = require('execa');\n\nconst { statSync } = require('fs');\nconst path = require('path');\nconst common = require('./common');\nconst EventEmitter = require('events').EventEmitter;\n\nconst { EOL } = require('os');\n\n/**\n * Constants\n */\n\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n\nconst typeMap = {\n  rename: CHANGE_EVENT,\n  write: CHANGE_EVENT,\n  remove: DELETE_EVENT,\n  create: ADD_EVENT,\n};\n\nconst messageRegexp = /(rename|write|remove|create)\\s(.+)/;\n\n/**\n * Manages streams from subprocess and turns into sane events\n *\n * @param {Stream} data\n * @private\n */\nfunction _messageHandler(data) {\n  data\n    .toString()\n    .split(EOL)\n    .filter(str => str.trim().length)\n    .filter(str => messageRegexp.test(str))\n    .map(line => {\n      const [, command, path] = [...line.match(messageRegexp)];\n      return [command, path];\n    })\n    .forEach(([command, file]) => {\n      let stat;\n      const type = typeMap[command];\n      if (type === DELETE_EVENT) {\n        stat = null;\n      } else {\n        try {\n          stat = statSync(file);\n        } catch (e) {\n          // There is likely a delete coming down the pipe.\n          if (e.code === 'ENOENT') {\n            return;\n          }\n          throw e;\n        }\n      }\n      this.emitEvent(type, path.relative(this.root, file), stat);\n    });\n}\n\n/**\n * Export `WatchexecWatcher` class.\n * Watches `dir`.\n *\n * @class WatchexecWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\nclass WatchexecWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n\n    common.assignOptions(this, opts);\n\n    this.root = path.resolve(dir);\n\n    this._process = execa(\n      'watchexec',\n      ['-n', '--', 'node', __dirname + '/watchexec_client.js'],\n      { cwd: dir }\n    );\n\n    this._process.stdout.on('data', _messageHandler.bind(this));\n    this._readyTimer = setTimeout(this.emit.bind(this, 'ready'), 1000);\n  }\n\n  close(callback) {\n    clearTimeout(this._readyTimer);\n    this.removeAllListeners();\n    this._process && !this._process.killed && this._process.kill();\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n\n  /**\n   * Transform and emit an event comming from the poller.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n  emitEvent(type, file, stat) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n}\n\nWatchexecWatcher._messageHandler = _messageHandler;\n\nmodule.exports = WatchexecWatcher;\n"]},"metadata":{},"sourceType":"script"}