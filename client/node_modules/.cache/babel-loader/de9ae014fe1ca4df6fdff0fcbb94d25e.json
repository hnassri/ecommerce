{"ast":null,"code":"'use strict';\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sane() {\n  const data = require('sane');\n\n  _sane = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSerializer() {\n  const data = _interopRequireDefault(require('jest-serializer'));\n\n  _jestSerializer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _node = _interopRequireDefault(require('./crawlers/node'));\n\nvar _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar _FSEventsWatcher = _interopRequireDefault(require('./lib/FSEventsWatcher'));\n\nvar _WatchmanWatcher = _interopRequireDefault(require('./lib/WatchmanWatcher'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _getPlatformExtension = _interopRequireDefault(require('./lib/getPlatformExtension'));\n\nvar _normalizePathSep = _interopRequireDefault(require('./lib/normalizePathSep'));\n\nvar _worker = require('./worker');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\n\n\nconst {\n  version: VERSION\n} = require('../package.json');\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\nconst NODE_MODULES = path().sep + 'node_modules' + path().sep;\nconst PACKAGE_JSON = path().sep + 'package.json';\nconst VCS_DIRECTORIES = ['.git', '.hg'].map(vcs => (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep)).join('|');\n\nconst canUseWatchman = (() => {\n  try {\n    (0, _child_process().execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch {}\n\n  return false;\n})();\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\n\nclass HasteMap extends _events().EventEmitter {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, '_buildPromise', void 0);\n\n    _defineProperty(this, '_cachePath', void 0);\n\n    _defineProperty(this, '_changeInterval', void 0);\n\n    _defineProperty(this, '_console', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_watchers', void 0);\n\n    _defineProperty(this, '_worker', void 0);\n\n    this._options = {\n      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),\n      computeDependencies: options.computeDependencies === undefined ? true : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor || null,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    this._console = options.console || global.console;\n\n    if (options.ignorePattern) {\n      if (options.ignorePattern instanceof RegExp) {\n        this._options.ignorePattern = new RegExp(options.ignorePattern.source.concat('|' + VCS_DIRECTORIES), options.ignorePattern.flags);\n      } else {\n        const ignorePattern = options.ignorePattern;\n        const vcsIgnoreRegExp = new RegExp(VCS_DIRECTORIES);\n\n        this._options.ignorePattern = filePath => vcsIgnoreRegExp.test(filePath) || ignorePattern(filePath);\n\n        this._console.warn('jest-haste-map: the `ignorePattern` options as a function is being ' + 'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.');\n      }\n    } else {\n      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);\n    }\n\n    const rootDirHash = (0, _crypto().createHash)('md5').update(options.rootDir).digest('hex');\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = require(options.dependencyExtractor);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(this._options.cacheDirectory, `haste-map-${this._options.name}-${rootDirHash}`, VERSION, this._options.name, this._options.roots.map(root => fastPath.relative(options.rootDir, root)).join(':'), this._options.extensions.join(':'), this._options.platforms.join(':'), this._options.computeSha1.toString(), options.mocksPattern || '', (options.ignorePattern || '').toString(), hasteImplHash, dependencyExtractorHash);\n    this._buildPromise = null;\n    this._watchers = [];\n    this._worker = null;\n  }\n\n  static getCacheFilePath(tmpdir, name, ...extra) {\n    const hash = (0, _crypto().createHash)('md5').update(extra.join(''));\n    return path().join(tmpdir, name.replace(/\\W/g, '-') + '-' + hash.digest('hex'));\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    if (!this._buildPromise) {\n      this._buildPromise = (async () => {\n        const data = await this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (data.changedFiles === undefined || data.changedFiles.size > 0 || data.removedFiles.size > 0) {\n          hasteMap = await this._buildHasteMap(data);\n\n          this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;\n\n        await this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = _jestSerializer().default.readFileSync(this._cachePath);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n\n  async _buildFileMap() {\n    let hasteMap;\n\n    try {\n      const read = this._options.resetCache ? this._createEmptyMap : this.read;\n      hasteMap = await read.call(this);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return this._crawl(hasteMap);\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform = (0, _getPlatformExtension.default)(module[_constants.default.PATH], this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (existingModule && existingModule[_constants.default.PATH] !== module[_constants.default.PATH]) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](['jest-haste-map: Haste module naming collision: ' + id, '  The following files share their name; please adjust your hasteImpl:', '    * <rootDir>' + path().sep + existingModule[_constants.default.PATH], '    * <rootDir>' + path().sep + module[_constants.default.PATH], ''].join('\\n'));\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(existingModule[_constants.default.PATH], module[_constants.default.PATH]);\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([[module[_constants.default.PATH], module[_constants.default.TYPE]], [existingModule[_constants.default.PATH], existingModule[_constants.default.TYPE]]]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(module[_constants.default.PATH], module[_constants.default.TYPE]);\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error('jest-haste-map: File to process was not found in the haste map.');\n    }\n\n    const moduleMetadata = hasteMap.map.get(fileMetadata[_constants.default.ID]);\n    const computeSha1 = this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM) : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      }\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n\n    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions).getSha1({\n          computeDependencies: this._options.computeDependencies,\n          computeSha1,\n          dependencyExtractor: this._options.dependencyExtractor,\n          filePath,\n          hasteImplModulePath: this._options.hasteImplModulePath,\n          rootDir\n        }).then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n          this._console[method](['jest-haste-map: duplicate manual mock found: ' + mockPath, '  The following files share their name; please delete one of them:', '    * <rootDir>' + path().sep + existingMockPath, '    * <rootDir>' + path().sep + secondMockPath, ''].join('\\n'));\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions).worker({\n      computeDependencies: this._options.computeDependencies,\n      computeSha1,\n      dependencyExtractor: this._options.dependencyExtractor,\n      filePath,\n      hasteImplModulePath: this._options.hasteImplModulePath,\n      rootDir\n    }).then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const {\n      removedFiles,\n      changedFiles,\n      hasteMap\n    } = data; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    for (const [relativeFilePath, fileMetadata] of removedFiles) {\n      this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[_constants.default.ID]);\n    }\n\n    const promises = [];\n\n    for (const relativeFilePath of filesToProcess.keys()) {\n      if (this._options.skipPackageJson && relativeFilePath.endsWith(PACKAGE_JSON)) {\n        continue;\n      } // SHA-1, if requested, should already be present thanks to the crawler.\n\n\n      const filePath = fastPath.resolve(this._options.rootDir, relativeFilePath);\n\n      const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n      if (promise) {\n        promises.push(promise);\n      }\n    }\n\n    return Promise.all(promises).then(() => {\n      this._cleanup();\n\n      hasteMap.map = map;\n      hasteMap.mocks = mocks;\n      return hasteMap;\n    }, error => {\n      this._cleanup();\n\n      throw error;\n    });\n  }\n\n  _cleanup() {\n    const worker = this._worker; // @ts-expect-error\n\n    if (worker && typeof worker.end === 'function') {\n      // @ts-expect-error\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n\n  _persist(hasteMap) {\n    _jestSerializer().default.writeFileSync(this._cachePath, hasteMap);\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n\n  _getWorker(options) {\n    if (!this._worker) {\n      if (options && options.forceInBand || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        // @ts-expect-error: assignment of a worker with custom properties.\n        this._worker = new (_jestWorker().default)(require.resolve('./worker'), {\n          exposedMethods: ['getSha1', 'worker'],\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers\n        });\n      }\n    }\n\n    return this._worker;\n  }\n\n  _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl = canUseWatchman && this._options.useWatchman ? _watchman.default : _node.default;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.default) {\n        this._console.warn(`jest-haste-map: Watchman crawl failed. Retrying once with node ` + `crawler.\\n` + `  Usually this happens when watchman isn't running. Create an ` + `empty \\`.watchmanconfig\\` file in your project's root folder or ` + `initialize a git or hg repository in your project.\\n` + `  ` + error);\n\n        return (0, _node.default)(crawlerOptions).catch(e => {\n          throw new Error(`Crawler retry failed:\\n` + `  Original error: ${error.message}\\n` + `  Retry error: ${e.message}\\n`);\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n\n  _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher = canUseWatchman && this._options.useWatchman ? _WatchmanWatcher.default : _FSEventsWatcher.default.isSupported() ? _FSEventsWatcher.default : _sane().NodeWatcher;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      // @ts-expect-error: TODO how? \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\"\n      const watcher = new Watcher(root, {\n        dot: true,\n        glob: extensions.map(extension => '**/*.' + extension),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(() => reject(new Error('Failed to start watch mode.')), MAX_WAIT_TIME);\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = path().join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (stat && stat.isDirectory() || this._ignore(filePath) || !extensions.some(extension => filePath.endsWith(extension))) {\n        return;\n      }\n\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const fileMetadata = hasteMap.files.get(relativeFilePath); // The file has been accessed, not modified\n\n      if (type === 'change' && fileMetadata && stat && fileMetadata[_constants.default.MTIME] === stat.mtime.getTime()) {\n        return;\n      }\n\n      changeQueue = changeQueue.then(() => {\n        // If we get duplicate events for the same file, ignore them.\n        if (eventsQueue.find(event => event.type === type && event.filePath === filePath && (!event.stat && !stat || !!event.stat && !!stat && event.stat.mtime.getTime() === stat.mtime.getTime()))) {\n          return null;\n        }\n\n        if (mustCopy) {\n          mustCopy = false;\n          hasteMap = {\n            clocks: new Map(hasteMap.clocks),\n            duplicates: new Map(hasteMap.duplicates),\n            files: new Map(hasteMap.files),\n            map: new Map(hasteMap.map),\n            mocks: new Map(hasteMap.mocks)\n          };\n        }\n\n        const add = () => {\n          eventsQueue.push({\n            filePath,\n            stat,\n            type\n          });\n          return null;\n        };\n\n        const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n        if (fileMetadata != null) {\n          const moduleName = fileMetadata[_constants.default.ID];\n\n          const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n          hasteMap.files.delete(relativeFilePath);\n          let moduleMap = hasteMap.map.get(moduleName);\n\n          if (moduleMap != null) {\n            // We are forced to copy the object because jest-haste-map exposes\n            // the map as an immutable entity.\n            moduleMap = copy(moduleMap);\n            delete moduleMap[platform];\n\n            if (Object.keys(moduleMap).length === 0) {\n              hasteMap.map.delete(moduleName);\n            } else {\n              hasteMap.map.set(moduleName, moduleMap);\n            }\n          }\n\n          if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n            const mockName = (0, _getMockName.default)(filePath);\n            hasteMap.mocks.delete(mockName);\n          }\n\n          this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n        } // If the file was added or changed,\n        // parse it and update the haste map.\n\n\n        if (type === 'add' || type === 'change') {\n          invariant(stat, 'since the file exists or changed, it should have stats');\n          const fileMetadata = ['', stat.mtime.getTime(), stat.size, 0, '', null];\n          hasteMap.files.set(relativeFilePath, fileMetadata);\n\n          const promise = this._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {\n            forceInBand: true\n          }); // Cleanup\n\n\n          this._cleanup();\n\n          if (promise) {\n            return promise.then(add);\n          } else {\n            // If a file in node_modules has changed,\n            // emit an event regardless.\n            add();\n          }\n        } else {\n          add();\n        }\n\n        return null;\n      }).catch(error => {\n        this._console.error(`jest-haste-map: watch error:\\n  ${error.stack}\\n`);\n      });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(watchers => {\n      this._watchers = watchers;\n    });\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform = (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (dedupMap == null) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  end() {\n    // @ts-expect-error: TODO TS cannot decide if `setInterval` and `clearInterval` comes from NodeJS or the DOM\n    clearInterval(this._changeInterval);\n\n    if (!this._watchers.length) {\n      return Promise.resolve();\n    }\n\n    return Promise.all(this._watchers.map(watcher => new Promise(resolve => watcher.close(resolve)))).then(() => {\n      this._watchers = [];\n    });\n  }\n  /**\n   * Helpers\n   */\n\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern && ignorePattern(filePath);\n    return ignoreMatched || !this._options.retainAllFiles && filePath.includes(NODE_MODULES);\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n\n}\n\n_defineProperty(HasteMap, 'H', void 0);\n\n_defineProperty(HasteMap, 'DuplicateError', void 0);\n\n_defineProperty(HasteMap, 'ModuleMap', void 0);\n\nclass DuplicateError extends Error {\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    _defineProperty(this, 'mockPath1', void 0);\n\n    _defineProperty(this, 'mockPath2', void 0);\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n\n}\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}\n\nHasteMap.H = _constants.default;\nHasteMap.DuplicateError = DuplicateError;\nHasteMap.ModuleMap = _ModuleMap.default;\nmodule.exports = HasteMap;","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/jest-haste-map/build/index.js"],"names":["_child_process","data","require","_crypto","_events","_os","path","_interopRequireWildcard","_sane","_jestRegexUtil","_jestSerializer","_interopRequireDefault","_jestWorker","_HasteFS","_ModuleMap","_constants","_node","_watchman","_getMockName","_FSEventsWatcher","_WatchmanWatcher","fastPath","_getPlatformExtension","_normalizePathSep","_worker","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","value","enumerable","configurable","writable","version","VERSION","CHANGE_INTERVAL","MAX_WAIT_TIME","NODE_MODULES","sep","PACKAGE_JSON","VCS_DIRECTORIES","map","vcs","escapePathForRegex","join","canUseWatchman","execSync","stdio","invariant","condition","message","Error","HasteMap","EventEmitter","constructor","options","_options","cacheDirectory","tmpdir","computeDependencies","undefined","computeSha1","dependencyExtractor","extensions","forceNodeFilesystemAPI","hasteImplModulePath","maxWorkers","mocksPattern","RegExp","name","platforms","resetCache","retainAllFiles","rootDir","roots","Array","from","Set","skipPackageJson","throwOnModuleCollision","useWatchman","watch","_console","console","global","ignorePattern","source","concat","flags","vcsIgnoreRegExp","filePath","test","warn","rootDirHash","createHash","update","digest","hasteImplHash","dependencyExtractorHash","hasteImpl","getCacheKey","String","_cachePath","getCacheFilePath","root","relative","toString","_buildPromise","_watchers","extra","hash","replace","build","_buildFileMap","hasteMap","changedFiles","size","removedFiles","_buildHasteMap","_persist","hasteFS","files","moduleMap","duplicates","mocks","__hasteMapForTest","process","env","NODE_ENV","_watch","read","readFileSync","_createEmptyMap","readModuleMap","_crawl","_processFile","workerOptions","setModule","id","module","create","platform","PATH","GENERIC_PLATFORM","existingModule","method","DuplicateError","keys","length","delete","dupsByPlatform","Map","dups","TYPE","relativeFilePath","fileMetadata","moduleMetadata","ID","SHA1","workerReply","metadata","VISITED","metadataId","metadataModule","DEPENDENCIES","dependencies","DEPENDENCY_DELIM","sha1","workerError","error","stack","includes","code","_getWorker","getSha1","then","mockPath","existingMockPath","secondMockPath","moduleId","modulesByPlatform","worker","filesToProcess","_recoverDuplicates","promises","endsWith","resolve","promise","push","Promise","all","_cleanup","end","writeFileSync","forceInBand","exposedMethods","maxRetries","numWorkers","ignore","_ignore","bind","crawl","crawlerOptions","retry","catch","e","Watcher","isSupported","NodeWatcher","changeQueue","eventsQueue","mustCopy","createWatcher","watcher","dot","glob","extension","ignored","reject","rejectTimeout","setTimeout","once","clearTimeout","on","onChange","emitChange","changeEvent","emit","type","stat","isDirectory","some","MTIME","mtime","getTime","find","event","clocks","add","moduleName","copy","mockName","_changeInterval","setInterval","watchers","copyMap","uniqueModule","entries","next","dedupMap","clearInterval","close","ignoreMatched","mockPath1","mockPath2","object","assign","input","H","ModuleMap","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sane() {\n  const data = require('sane');\n\n  _sane = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSerializer() {\n  const data = _interopRequireDefault(require('jest-serializer'));\n\n  _jestSerializer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _node = _interopRequireDefault(require('./crawlers/node'));\n\nvar _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar _FSEventsWatcher = _interopRequireDefault(require('./lib/FSEventsWatcher'));\n\nvar _WatchmanWatcher = _interopRequireDefault(require('./lib/WatchmanWatcher'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _getPlatformExtension = _interopRequireDefault(\n  require('./lib/getPlatformExtension')\n);\n\nvar _normalizePathSep = _interopRequireDefault(\n  require('./lib/normalizePathSep')\n);\n\nvar _worker = require('./worker');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\nconst {version: VERSION} = require('../package.json');\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\nconst NODE_MODULES = path().sep + 'node_modules' + path().sep;\nconst PACKAGE_JSON = path().sep + 'package.json';\nconst VCS_DIRECTORIES = ['.git', '.hg']\n  .map(vcs =>\n    (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep)\n  )\n  .join('|');\n\nconst canUseWatchman = (() => {\n  try {\n    (0, _child_process().execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch {}\n\n  return false;\n})();\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\nclass HasteMap extends _events().EventEmitter {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, '_buildPromise', void 0);\n\n    _defineProperty(this, '_cachePath', void 0);\n\n    _defineProperty(this, '_changeInterval', void 0);\n\n    _defineProperty(this, '_console', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_watchers', void 0);\n\n    _defineProperty(this, '_worker', void 0);\n\n    this._options = {\n      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),\n      computeDependencies:\n        options.computeDependencies === undefined\n          ? true\n          : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor || null,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern\n        ? new RegExp(options.mocksPattern)\n        : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    this._console = options.console || global.console;\n\n    if (options.ignorePattern) {\n      if (options.ignorePattern instanceof RegExp) {\n        this._options.ignorePattern = new RegExp(\n          options.ignorePattern.source.concat('|' + VCS_DIRECTORIES),\n          options.ignorePattern.flags\n        );\n      } else {\n        const ignorePattern = options.ignorePattern;\n        const vcsIgnoreRegExp = new RegExp(VCS_DIRECTORIES);\n\n        this._options.ignorePattern = filePath =>\n          vcsIgnoreRegExp.test(filePath) || ignorePattern(filePath);\n\n        this._console.warn(\n          'jest-haste-map: the `ignorePattern` options as a function is being ' +\n            'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.'\n        );\n      }\n    } else {\n      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);\n    }\n\n    const rootDirHash = (0, _crypto().createHash)('md5')\n      .update(options.rootDir)\n      .digest('hex');\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = require(options.dependencyExtractor);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(\n      this._options.cacheDirectory,\n      `haste-map-${this._options.name}-${rootDirHash}`,\n      VERSION,\n      this._options.name,\n      this._options.roots\n        .map(root => fastPath.relative(options.rootDir, root))\n        .join(':'),\n      this._options.extensions.join(':'),\n      this._options.platforms.join(':'),\n      this._options.computeSha1.toString(),\n      options.mocksPattern || '',\n      (options.ignorePattern || '').toString(),\n      hasteImplHash,\n      dependencyExtractorHash\n    );\n    this._buildPromise = null;\n    this._watchers = [];\n    this._worker = null;\n  }\n\n  static getCacheFilePath(tmpdir, name, ...extra) {\n    const hash = (0, _crypto().createHash)('md5').update(extra.join(''));\n    return path().join(\n      tmpdir,\n      name.replace(/\\W/g, '-') + '-' + hash.digest('hex')\n    );\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    if (!this._buildPromise) {\n      this._buildPromise = (async () => {\n        const data = await this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (\n          data.changedFiles === undefined ||\n          data.changedFiles.size > 0 ||\n          data.removedFiles.size > 0\n        ) {\n          hasteMap = await this._buildHasteMap(data);\n\n          this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest =\n          (process.env.NODE_ENV === 'test' && hasteMap) || null;\n\n        await this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = _jestSerializer().default.readFileSync(this._cachePath);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n  async _buildFileMap() {\n    let hasteMap;\n\n    try {\n      const read = this._options.resetCache ? this._createEmptyMap : this.read;\n      hasteMap = await read.call(this);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return this._crawl(hasteMap);\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform =\n        (0, _getPlatformExtension.default)(\n          module[_constants.default.PATH],\n          this._options.platforms\n        ) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (\n        existingModule &&\n        existingModule[_constants.default.PATH] !==\n          module[_constants.default.PATH]\n      ) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](\n          [\n            'jest-haste-map: Haste module naming collision: ' + id,\n            '  The following files share their name; please adjust your hasteImpl:',\n            '    * <rootDir>' +\n              path().sep +\n              existingModule[_constants.default.PATH],\n            '    * <rootDir>' + path().sep + module[_constants.default.PATH],\n            ''\n          ].join('\\n')\n        );\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(\n            existingModule[_constants.default.PATH],\n            module[_constants.default.PATH]\n          );\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([\n          [module[_constants.default.PATH], module[_constants.default.TYPE]],\n          [\n            existingModule[_constants.default.PATH],\n            existingModule[_constants.default.TYPE]\n          ]\n        ]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(\n            module[_constants.default.PATH],\n            module[_constants.default.TYPE]\n          );\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error(\n        'jest-haste-map: File to process was not found in the haste map.'\n      );\n    }\n\n    const moduleMetadata = hasteMap.map.get(\n      fileMetadata[_constants.default.ID]\n    );\n    const computeSha1 =\n      this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies\n        ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM)\n        : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      }\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions)\n          .getSha1({\n            computeDependencies: this._options.computeDependencies,\n            computeSha1,\n            dependencyExtractor: this._options.dependencyExtractor,\n            filePath,\n            hasteImplModulePath: this._options.hasteImplModulePath,\n            rootDir\n          })\n          .then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (\n      this._options.mocksPattern &&\n      this._options.mocksPattern.test(filePath)\n    ) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision\n            ? 'error'\n            : 'warn';\n\n          this._console[method](\n            [\n              'jest-haste-map: duplicate manual mock found: ' + mockPath,\n              '  The following files share their name; please delete one of them:',\n              '    * <rootDir>' + path().sep + existingMockPath,\n              '    * <rootDir>' + path().sep + secondMockPath,\n              ''\n            ].join('\\n')\n          );\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform =\n          (0, _getPlatformExtension.default)(\n            filePath,\n            this._options.platforms\n          ) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions)\n      .worker({\n        computeDependencies: this._options.computeDependencies,\n        computeSha1,\n        dependencyExtractor: this._options.dependencyExtractor,\n        filePath,\n        hasteImplModulePath: this._options.hasteImplModulePath,\n        rootDir\n      })\n      .then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const {removedFiles, changedFiles, hasteMap} = data; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    for (const [relativeFilePath, fileMetadata] of removedFiles) {\n      this._recoverDuplicates(\n        hasteMap,\n        relativeFilePath,\n        fileMetadata[_constants.default.ID]\n      );\n    }\n\n    const promises = [];\n\n    for (const relativeFilePath of filesToProcess.keys()) {\n      if (\n        this._options.skipPackageJson &&\n        relativeFilePath.endsWith(PACKAGE_JSON)\n      ) {\n        continue;\n      } // SHA-1, if requested, should already be present thanks to the crawler.\n\n      const filePath = fastPath.resolve(\n        this._options.rootDir,\n        relativeFilePath\n      );\n\n      const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n      if (promise) {\n        promises.push(promise);\n      }\n    }\n\n    return Promise.all(promises).then(\n      () => {\n        this._cleanup();\n\n        hasteMap.map = map;\n        hasteMap.mocks = mocks;\n        return hasteMap;\n      },\n      error => {\n        this._cleanup();\n\n        throw error;\n      }\n    );\n  }\n\n  _cleanup() {\n    const worker = this._worker; // @ts-expect-error\n\n    if (worker && typeof worker.end === 'function') {\n      // @ts-expect-error\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n  _persist(hasteMap) {\n    _jestSerializer().default.writeFileSync(this._cachePath, hasteMap);\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n  _getWorker(options) {\n    if (!this._worker) {\n      if ((options && options.forceInBand) || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        // @ts-expect-error: assignment of a worker with custom properties.\n        this._worker = new (_jestWorker().default)(\n          require.resolve('./worker'),\n          {\n            exposedMethods: ['getSha1', 'worker'],\n            maxRetries: 3,\n            numWorkers: this._options.maxWorkers\n          }\n        );\n      }\n    }\n\n    return this._worker;\n  }\n\n  _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl =\n      canUseWatchman && this._options.useWatchman\n        ? _watchman.default\n        : _node.default;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.default) {\n        this._console.warn(\n          `jest-haste-map: Watchman crawl failed. Retrying once with node ` +\n            `crawler.\\n` +\n            `  Usually this happens when watchman isn't running. Create an ` +\n            `empty \\`.watchmanconfig\\` file in your project's root folder or ` +\n            `initialize a git or hg repository in your project.\\n` +\n            `  ` +\n            error\n        );\n\n        return (0, _node.default)(crawlerOptions).catch(e => {\n          throw new Error(\n            `Crawler retry failed:\\n` +\n              `  Original error: ${error.message}\\n` +\n              `  Retry error: ${e.message}\\n`\n          );\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n  _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher =\n      canUseWatchman && this._options.useWatchman\n        ? _WatchmanWatcher.default\n        : _FSEventsWatcher.default.isSupported()\n        ? _FSEventsWatcher.default\n        : _sane().NodeWatcher;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      // @ts-expect-error: TODO how? \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\"\n      const watcher = new Watcher(root, {\n        dot: true,\n        glob: extensions.map(extension => '**/*.' + extension),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(\n          () => reject(new Error('Failed to start watch mode.')),\n          MAX_WAIT_TIME\n        );\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = path().join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (\n        (stat && stat.isDirectory()) ||\n        this._ignore(filePath) ||\n        !extensions.some(extension => filePath.endsWith(extension))\n      ) {\n        return;\n      }\n\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const fileMetadata = hasteMap.files.get(relativeFilePath); // The file has been accessed, not modified\n\n      if (\n        type === 'change' &&\n        fileMetadata &&\n        stat &&\n        fileMetadata[_constants.default.MTIME] === stat.mtime.getTime()\n      ) {\n        return;\n      }\n\n      changeQueue = changeQueue\n        .then(() => {\n          // If we get duplicate events for the same file, ignore them.\n          if (\n            eventsQueue.find(\n              event =>\n                event.type === type &&\n                event.filePath === filePath &&\n                ((!event.stat && !stat) ||\n                  (!!event.stat &&\n                    !!stat &&\n                    event.stat.mtime.getTime() === stat.mtime.getTime()))\n            )\n          ) {\n            return null;\n          }\n\n          if (mustCopy) {\n            mustCopy = false;\n            hasteMap = {\n              clocks: new Map(hasteMap.clocks),\n              duplicates: new Map(hasteMap.duplicates),\n              files: new Map(hasteMap.files),\n              map: new Map(hasteMap.map),\n              mocks: new Map(hasteMap.mocks)\n            };\n          }\n\n          const add = () => {\n            eventsQueue.push({\n              filePath,\n              stat,\n              type\n            });\n            return null;\n          };\n\n          const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n          if (fileMetadata != null) {\n            const moduleName = fileMetadata[_constants.default.ID];\n\n            const platform =\n              (0, _getPlatformExtension.default)(\n                filePath,\n                this._options.platforms\n              ) || _constants.default.GENERIC_PLATFORM;\n\n            hasteMap.files.delete(relativeFilePath);\n            let moduleMap = hasteMap.map.get(moduleName);\n\n            if (moduleMap != null) {\n              // We are forced to copy the object because jest-haste-map exposes\n              // the map as an immutable entity.\n              moduleMap = copy(moduleMap);\n              delete moduleMap[platform];\n\n              if (Object.keys(moduleMap).length === 0) {\n                hasteMap.map.delete(moduleName);\n              } else {\n                hasteMap.map.set(moduleName, moduleMap);\n              }\n            }\n\n            if (\n              this._options.mocksPattern &&\n              this._options.mocksPattern.test(filePath)\n            ) {\n              const mockName = (0, _getMockName.default)(filePath);\n              hasteMap.mocks.delete(mockName);\n            }\n\n            this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n          } // If the file was added or changed,\n          // parse it and update the haste map.\n\n          if (type === 'add' || type === 'change') {\n            invariant(\n              stat,\n              'since the file exists or changed, it should have stats'\n            );\n            const fileMetadata = [\n              '',\n              stat.mtime.getTime(),\n              stat.size,\n              0,\n              '',\n              null\n            ];\n            hasteMap.files.set(relativeFilePath, fileMetadata);\n\n            const promise = this._processFile(\n              hasteMap,\n              hasteMap.map,\n              hasteMap.mocks,\n              filePath,\n              {\n                forceInBand: true\n              }\n            ); // Cleanup\n\n            this._cleanup();\n\n            if (promise) {\n              return promise.then(add);\n            } else {\n              // If a file in node_modules has changed,\n              // emit an event regardless.\n              add();\n            }\n          } else {\n            add();\n          }\n\n          return null;\n        })\n        .catch(error => {\n          this._console.error(\n            `jest-haste-map: watch error:\\n  ${error.stack}\\n`\n          );\n        });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(\n      watchers => {\n        this._watchers = watchers;\n      }\n    );\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform =\n      (0, _getPlatformExtension.default)(\n        relativeFilePath,\n        this._options.platforms\n      ) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (dedupMap == null) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  end() {\n    // @ts-expect-error: TODO TS cannot decide if `setInterval` and `clearInterval` comes from NodeJS or the DOM\n    clearInterval(this._changeInterval);\n\n    if (!this._watchers.length) {\n      return Promise.resolve();\n    }\n\n    return Promise.all(\n      this._watchers.map(\n        watcher => new Promise(resolve => watcher.close(resolve))\n      )\n    ).then(() => {\n      this._watchers = [];\n    });\n  }\n  /**\n   * Helpers\n   */\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched =\n      ignorePattern instanceof RegExp\n        ? ignorePattern.test(filePath)\n        : ignorePattern && ignorePattern(filePath);\n    return (\n      ignoreMatched ||\n      (!this._options.retainAllFiles && filePath.includes(NODE_MODULES))\n    );\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n}\n\n_defineProperty(HasteMap, 'H', void 0);\n\n_defineProperty(HasteMap, 'DuplicateError', void 0);\n\n_defineProperty(HasteMap, 'ModuleMap', void 0);\n\nclass DuplicateError extends Error {\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    _defineProperty(this, 'mockPath1', void 0);\n\n    _defineProperty(this, 'mockPath2', void 0);\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n}\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}\n\nHasteMap.H = _constants.default;\nHasteMap.DuplicateError = DuplicateError;\nHasteMap.ModuleMap = _ModuleMap.default;\nmodule.exports = HasteMap;\n"]},"metadata":{},"sourceType":"script"}