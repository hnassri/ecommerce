{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst common = require('./common');\n\nconst watchmanClient = require('./watchman_client');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst RecrawlWarning = require('./utils/recrawl-warning-dedupe');\n/**\n * Constants\n */\n\n\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n/**\n * Export `WatchmanWatcher` class.\n */\n\nmodule.exports = WatchmanWatcher;\n/**\n * Watches `dir`.\n *\n * @class WatchmanWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  common.assignOptions(this, opts);\n  this.root = path.resolve(dir);\n\n  this._init();\n}\n\nWatchmanWatcher.prototype.__proto__ = EventEmitter.prototype;\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\n\nWatchmanWatcher.prototype._init = function () {\n  if (this._client) {\n    this._client = null;\n  } // Get the WatchmanClient instance corresponding to our watchmanPath (or nothing).\n  // Then subscribe, which will do the appropriate setup so that we will receive\n  // calls to handleChangeEvent when files change.\n\n\n  this._client = watchmanClient.getInstance(this.watchmanPath);\n  return this._client.subscribe(this, this.root).then(resp => {\n    this._handleWarning(resp);\n\n    this.emit('ready');\n  }, error => {\n    this._handleError(error);\n  });\n};\n/**\n * Called by WatchmanClient to create the options, either during initial 'subscribe'\n * or to resubscribe after a disconnect+reconnect. Note that we are leaving out\n * the watchman 'since' and 'relative_root' options, which are handled inside the\n * WatchmanClient.\n */\n\n\nWatchmanWatcher.prototype.createOptions = function () {\n  let options = {\n    fields: ['name', 'exists', 'new']\n  }; // If the server has the wildmatch capability available it supports\n  // the recursive **/*.foo style match and we can offload our globs\n  // to the watchman server.  This saves both on data size to be\n  // communicated back to us and compute for evaluating the globs\n  // in our node process.\n\n  if (this._client.wildmatch) {\n    if (this.globs.length === 0) {\n      if (!this.dot) {\n        // Make sure we honor the dot option if even we're not using globs.\n        options.expression = ['match', '**', 'wholename', {\n          includedotfiles: false\n        }];\n      }\n    } else {\n      options.expression = ['anyof'];\n\n      for (let i in this.globs) {\n        options.expression.push(['match', this.globs[i], 'wholename', {\n          includedotfiles: this.dot\n        }]);\n      }\n    }\n  }\n\n  return options;\n};\n/**\n * Called by WatchmanClient when it receives an error from the watchman daemon.\n *\n * @param {Object} resp\n */\n\n\nWatchmanWatcher.prototype.handleErrorEvent = function (error) {\n  this.emit('error', error);\n};\n/**\n * Called by the WatchmanClient when it is notified about a file change in\n * the tree for this particular watcher's root.\n *\n * @param {Object} resp\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleChangeEvent = function (resp) {\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleFileChange = function (changeDescriptor) {\n  let absPath;\n  let relativePath;\n  relativePath = changeDescriptor.name;\n  absPath = path.join(this.root, relativePath);\n\n  if (!(this._client.wildmatch && !this.hasIgnore) && !common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n    return;\n  }\n\n  if (!changeDescriptor.exists) {\n    this.emitEvent(DELETE_EVENT, relativePath, this.root);\n  } else {\n    fs.lstat(absPath, (error, stat) => {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n\n      if (this._handleError(error)) {\n        return;\n      }\n\n      let eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT; // Change event on dirs are mostly useless.\n\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        this.emitEvent(eventType, relativePath, this.root, stat);\n      }\n    });\n  }\n};\n/**\n * Dispatches an event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\n\nWatchmanWatcher.prototype.emitEvent = function (eventType, filepath, root, stat) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n/**\n * Closes the watcher.\n *\n * @param {function} callback\n * @private\n */\n\n\nWatchmanWatcher.prototype.close = function (callback) {\n  this._client.closeWatcher(this);\n\n  callback && callback(null, true);\n};\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\n\nWatchmanWatcher.prototype._handleError = function (error) {\n  if (error != null) {\n    this.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n};\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\n\nWatchmanWatcher.prototype._handleWarning = function (resp) {\n  if ('warning' in resp) {\n    if (RecrawlWarning.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n};","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/sane/src/watchman_watcher.js"],"names":["fs","require","path","common","watchmanClient","EventEmitter","RecrawlWarning","CHANGE_EVENT","DELETE_EVENT","ADD_EVENT","ALL_EVENT","module","exports","WatchmanWatcher","dir","opts","assignOptions","root","resolve","_init","prototype","__proto__","_client","getInstance","watchmanPath","subscribe","then","resp","_handleWarning","emit","error","_handleError","createOptions","options","fields","wildmatch","globs","length","dot","expression","includedotfiles","i","push","handleErrorEvent","handleChangeEvent","Array","isArray","files","forEach","handleFileChange","changeDescriptor","absPath","relativePath","name","join","hasIgnore","isFileIncluded","doIgnore","exists","emitEvent","lstat","stat","code","eventType","new","isDirectory","filepath","close","callback","closeWatcher","isRecrawlWarningDupe","warning","console","warn"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst common = require('./common');\nconst watchmanClient = require('./watchman_client');\nconst EventEmitter = require('events').EventEmitter;\nconst RecrawlWarning = require('./utils/recrawl-warning-dedupe');\n\n/**\n * Constants\n */\n\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n\n/**\n * Export `WatchmanWatcher` class.\n */\n\nmodule.exports = WatchmanWatcher;\n\n/**\n * Watches `dir`.\n *\n * @class WatchmanWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  common.assignOptions(this, opts);\n  this.root = path.resolve(dir);\n  this._init();\n}\n\nWatchmanWatcher.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\nWatchmanWatcher.prototype._init = function() {\n  if (this._client) {\n    this._client = null;\n  }\n\n  // Get the WatchmanClient instance corresponding to our watchmanPath (or nothing).\n  // Then subscribe, which will do the appropriate setup so that we will receive\n  // calls to handleChangeEvent when files change.\n  this._client = watchmanClient.getInstance(this.watchmanPath);\n\n  return this._client.subscribe(this, this.root).then(\n    resp => {\n      this._handleWarning(resp);\n      this.emit('ready');\n    },\n    error => {\n      this._handleError(error);\n    }\n  );\n};\n\n/**\n * Called by WatchmanClient to create the options, either during initial 'subscribe'\n * or to resubscribe after a disconnect+reconnect. Note that we are leaving out\n * the watchman 'since' and 'relative_root' options, which are handled inside the\n * WatchmanClient.\n */\nWatchmanWatcher.prototype.createOptions = function() {\n  let options = {\n    fields: ['name', 'exists', 'new'],\n  };\n\n  // If the server has the wildmatch capability available it supports\n  // the recursive **/*.foo style match and we can offload our globs\n  // to the watchman server.  This saves both on data size to be\n  // communicated back to us and compute for evaluating the globs\n  // in our node process.\n  if (this._client.wildmatch) {\n    if (this.globs.length === 0) {\n      if (!this.dot) {\n        // Make sure we honor the dot option if even we're not using globs.\n        options.expression = [\n          'match',\n          '**',\n          'wholename',\n          {\n            includedotfiles: false,\n          },\n        ];\n      }\n    } else {\n      options.expression = ['anyof'];\n      for (let i in this.globs) {\n        options.expression.push([\n          'match',\n          this.globs[i],\n          'wholename',\n          {\n            includedotfiles: this.dot,\n          },\n        ]);\n      }\n    }\n  }\n\n  return options;\n};\n\n/**\n * Called by WatchmanClient when it receives an error from the watchman daemon.\n *\n * @param {Object} resp\n */\nWatchmanWatcher.prototype.handleErrorEvent = function(error) {\n  this.emit('error', error);\n};\n\n/**\n * Called by the WatchmanClient when it is notified about a file change in\n * the tree for this particular watcher's root.\n *\n * @param {Object} resp\n * @private\n */\n\nWatchmanWatcher.prototype.handleChangeEvent = function(resp) {\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\nWatchmanWatcher.prototype.handleFileChange = function(changeDescriptor) {\n  let absPath;\n  let relativePath;\n\n  relativePath = changeDescriptor.name;\n  absPath = path.join(this.root, relativePath);\n\n  if (\n    !(this._client.wildmatch && !this.hasIgnore) &&\n    !common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)\n  ) {\n    return;\n  }\n\n  if (!changeDescriptor.exists) {\n    this.emitEvent(DELETE_EVENT, relativePath, this.root);\n  } else {\n    fs.lstat(absPath, (error, stat) => {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n\n      if (this._handleError(error)) {\n        return;\n      }\n\n      let eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT;\n\n      // Change event on dirs are mostly useless.\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        this.emitEvent(eventType, relativePath, this.root, stat);\n      }\n    });\n  }\n};\n\n/**\n * Dispatches an event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\nWatchmanWatcher.prototype.emitEvent = function(\n  eventType,\n  filepath,\n  root,\n  stat\n) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n\n/**\n * Closes the watcher.\n *\n * @param {function} callback\n * @private\n */\n\nWatchmanWatcher.prototype.close = function(callback) {\n  this._client.closeWatcher(this);\n  callback && callback(null, true);\n};\n\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\nWatchmanWatcher.prototype._handleError = function(error) {\n  if (error != null) {\n    this.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\nWatchmanWatcher.prototype._handleWarning = function(resp) {\n  if ('warning' in resp) {\n    if (RecrawlWarning.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}