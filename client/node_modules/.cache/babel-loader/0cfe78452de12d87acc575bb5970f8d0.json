{"ast":null,"code":"/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\nvar EE = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar os = require('os');\n\nvar assert = require('assert');\n\nvar Int64 = require('node-int64'); // BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\n\n\nvar isBigEndian = os.endianness() == 'BE'; // Find the next power-of-2 >= size\n\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n} // Expandable buffer that we can provide a size hint for\n\n\nfunction Accumulator(initsize) {\n  this.buf = Buffer.alloc(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n} // For testing\n\n\nexports.Accumulator = Accumulator; // How much we can write into this buffer without allocating\n\nAccumulator.prototype.writeAvail = function () {\n  return this.buf.length - this.writeOffset;\n}; // How much we can read\n\n\nAccumulator.prototype.readAvail = function () {\n  return this.writeOffset - this.readOffset;\n}; // Ensure that we have enough space for size bytes\n\n\nAccumulator.prototype.reserve = function (size) {\n  if (size < this.writeAvail()) {\n    return;\n  } // If we can make room by shunting down, do so\n\n\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  } // If we made enough room, no need to allocate more\n\n\n  if (size < this.writeAvail()) {\n    return;\n  } // Allocate a replacement and copy it in\n\n\n  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}; // Append buffer or string.  Will resize as needed\n\n\nAccumulator.prototype.append = function (buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n};\n\nAccumulator.prototype.assertReadableSize = function (size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size + \" bytes but only have \" + this.readAvail());\n  }\n};\n\nAccumulator.prototype.peekString = function (size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n};\n\nAccumulator.prototype.readString = function (size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n};\n\nAccumulator.prototype.peekInt = function (size) {\n  this.assertReadableSize(size);\n\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n\n    case 2:\n      return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);\n\n    case 4:\n      return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);\n\n    case 8:\n      var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n\n      if (isBigEndian) {\n        // On a big endian system we can simply pass the buffer directly\n        return new Int64(big);\n      } // Otherwise we need to byteswap\n\n\n      return new Int64(byteswap64(big));\n\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n};\n\nAccumulator.prototype.readInt = function (bytes) {\n  var ival = this.peekInt(bytes);\n\n  if (ival instanceof Int64 && isFinite(ival.valueOf())) {\n    ival = ival.valueOf();\n  }\n\n  this.readOffset += bytes;\n  return ival;\n};\n\nAccumulator.prototype.peekDouble = function () {\n  this.assertReadableSize(8);\n  return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);\n};\n\nAccumulator.prototype.readDouble = function () {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n};\n\nAccumulator.prototype.readAdvance = function (size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size + \" would seek off the start of the buffer\");\n  }\n\n  this.readOffset += size;\n};\n\nAccumulator.prototype.writeByte = function (value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n};\n\nAccumulator.prototype.writeInt = function (value, size) {\n  this.reserve(size);\n\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n\n      break;\n\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n\n  this.writeOffset += size;\n};\n\nAccumulator.prototype.writeDouble = function (value) {\n  this.reserve(8);\n\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n\n  this.writeOffset += 8;\n};\n\nvar BSER_ARRAY = 0x00;\nvar BSER_OBJECT = 0x01;\nvar BSER_STRING = 0x02;\nvar BSER_INT8 = 0x03;\nvar BSER_INT16 = 0x04;\nvar BSER_INT32 = 0x05;\nvar BSER_INT64 = 0x06;\nvar BSER_REAL = 0x07;\nvar BSER_TRUE = 0x08;\nvar BSER_FALSE = 0x09;\nvar BSER_NULL = 0x0a;\nvar BSER_TEMPLATE = 0x0b;\nvar BSER_SKIP = 0x0c;\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\n\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32767;\nvar MAX_INT32 = 2147483647;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\n\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function (buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  } // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n\n\n  this.processLater();\n};\n\nBunserBuf.prototype.processLater = function () {\n  var self = this;\n  process.nextTick(function () {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}; // Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\n\n\nBunserBuf.prototype.process = function (synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    } // Validate BSER header\n\n\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true\n    /* relaxed */\n    );\n\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    } // Ensure that we have a big enough buffer to read the rest of the PDU\n\n\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    } // We have enough to decode it\n\n\n    var val = this.decodeAny();\n\n    if (synchronous) {\n      return val;\n    }\n\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n};\n\nBunserBuf.prototype.raise = function (reason) {\n  throw new Error(reason + \", in Buffer of length \" + this.buf.buf.length + \" (\" + this.buf.readAvail() + \" readable) at offset \" + this.buf.readOffset + \" buffer: \" + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n};\n\nBunserBuf.prototype.expectCode = function (expected) {\n  var code = this.buf.readInt(1);\n\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeAny = function () {\n  var code = this.buf.peekInt(1);\n\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n\n    case BSER_STRING:\n      return this.decodeString();\n\n    case BSER_ARRAY:\n      return this.decodeArray();\n\n    case BSER_OBJECT:\n      return this.decodeObject();\n\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeArray = function () {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeObject = function () {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n\n  return res;\n};\n\nBunserBuf.prototype.decodeTemplate = function () {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n\n    arr.push(obj);\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeString = function () {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}; // This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\n\n\nBunserBuf.prototype.decodeInt = function (relaxSizeAsserts) {\n  if (relaxSizeAsserts && this.buf.readAvail() < 1) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n\n  var code = this.buf.peekInt(1);\n  var size = 0;\n\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n\n    case BSER_INT16:\n      size = 2;\n      break;\n\n    case BSER_INT32:\n      size = 4;\n      break;\n\n    case BSER_INT64:\n      size = 8;\n      break;\n\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {\n    return false;\n  }\n\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}; // synchronously BSER decode a string and return the value\n\n\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n\n  if (buf.buf.readAvail()) {\n    throw Error('excess data found after input buffer, use BunserBuf instead');\n  }\n\n  if (typeof result === 'undefined') {\n    throw Error('no bser found in string and no error raised!?');\n  }\n\n  return result;\n}\n\nexports.loadFromBuffer = loadFromBuffer; // Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\n\nfunction byteswap64(buf) {\n  var swap = Buffer.alloc(buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length - 1 - i];\n  }\n\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  } // We need to byte swap to get the correct representation\n\n\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof val) {\n    case 'number':\n      // check if it is an integer or a float\n      if (isFinite(val) && Math.floor(val) === val) {\n        dump_int(buf, val);\n      } else {\n        buf.writeByte(BSER_REAL);\n        buf.writeDouble(val);\n      }\n\n      return;\n\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n\n        return;\n      }\n\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val); // First pass to compute number of defined keys\n\n      var num_keys = keys.length;\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          num_keys--;\n        }\n      }\n\n      dump_int(buf, num_keys);\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          // Don't include it\n          continue;\n        }\n\n        dump_any(buf, key);\n\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(e.message + ' (while serializing object property with name `' + key + \"')\");\n        }\n      }\n\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof val + ' to BSER');\n  }\n} // BSER encode value and return a buffer of the contents\n\n\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator(); // Build out the header\n\n  buf.writeByte(0);\n  buf.writeByte(1); // Reserve room for an int32 to hold our PDU length\n\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val); // Compute PDU length\n\n  var off = buf.writeOffset;\n  var len = off - 7\n  /* the header length */\n  ;\n  buf.writeOffset = 3; // The length value to fill in\n\n  buf.writeInt(len, 4); // write the length in the space we reserved\n\n  buf.writeOffset = off;\n  return buf.buf.slice(0, off);\n}\n\nexports.dumpToBuffer = dumpToBuffer;","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/bser/index.js"],"names":["EE","require","EventEmitter","util","os","assert","Int64","isBigEndian","endianness","nextPow2","size","Math","pow","ceil","log","LN2","Accumulator","initsize","buf","Buffer","alloc","readOffset","writeOffset","exports","prototype","writeAvail","length","readAvail","reserve","copy","append","isBuffer","byteLength","write","assertReadableSize","Error","peekString","toString","readString","str","peekInt","readInt8","readInt16BE","readInt16LE","readInt32BE","readInt32LE","big","slice","byteswap64","readInt","bytes","ival","isFinite","valueOf","peekDouble","readDoubleBE","readDoubleLE","readDouble","dval","readAdvance","writeByte","value","writeInt8","writeInt","writeInt16BE","writeInt16LE","writeInt32BE","writeInt32LE","writeDouble","writeDoubleBE","writeDoubleLE","BSER_ARRAY","BSER_OBJECT","BSER_STRING","BSER_INT8","BSER_INT16","BSER_INT32","BSER_INT64","BSER_REAL","BSER_TRUE","BSER_FALSE","BSER_NULL","BSER_TEMPLATE","BSER_SKIP","ST_NEED_PDU","ST_FILL_PDU","MAX_INT8","MAX_INT16","MAX_INT32","BunserBuf","call","state","inherits","synchronous","process","err","emit","processLater","self","nextTick","expectCode","pduLen","decodeInt","val","decodeAny","raise","reason","JSON","stringify","toJSON","expected","code","decodeString","decodeArray","decodeObject","decodeTemplate","nitems","arr","i","push","res","key","keys","obj","keyidx","len","relaxSizeAsserts","loadFromBuffer","input","result","swap","dump_int64","be","toBuffer","le","dump_int","abs","dump_any","floor","Array","isArray","Object","num_keys","v","e","message","dumpToBuffer","off"],"mappings":"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","sourcesContent":["/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\nvar EE = require('events').EventEmitter;\nvar util = require('util');\nvar os = require('os');\nvar assert = require('assert');\nvar Int64 = require('node-int64');\n\n// BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\nvar isBigEndian = os.endianness() == 'BE';\n\n// Find the next power-of-2 >= size\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n}\n\n// Expandable buffer that we can provide a size hint for\nfunction Accumulator(initsize) {\n  this.buf = Buffer.alloc(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n}\n// For testing\nexports.Accumulator = Accumulator\n\n// How much we can write into this buffer without allocating\nAccumulator.prototype.writeAvail = function() {\n  return this.buf.length - this.writeOffset;\n}\n\n// How much we can read\nAccumulator.prototype.readAvail = function() {\n  return this.writeOffset - this.readOffset;\n}\n\n// Ensure that we have enough space for size bytes\nAccumulator.prototype.reserve = function(size) {\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // If we can make room by shunting down, do so\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  }\n\n  // If we made enough room, no need to allocate more\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // Allocate a replacement and copy it in\n  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}\n\n// Append buffer or string.  Will resize as needed\nAccumulator.prototype.append = function(buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n}\n\nAccumulator.prototype.assertReadableSize = function(size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size +\n        \" bytes but only have \" + this.readAvail());\n  }\n}\n\nAccumulator.prototype.peekString = function(size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n}\n\nAccumulator.prototype.readString = function(size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n}\n\nAccumulator.prototype.peekInt = function(size) {\n  this.assertReadableSize(size);\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n    case 2:\n      return isBigEndian ?\n        this.buf.readInt16BE(this.readOffset, size) :\n        this.buf.readInt16LE(this.readOffset, size);\n    case 4:\n      return isBigEndian ?\n        this.buf.readInt32BE(this.readOffset, size) :\n        this.buf.readInt32LE(this.readOffset, size);\n    case 8:\n        var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n        if (isBigEndian) {\n          // On a big endian system we can simply pass the buffer directly\n          return new Int64(big);\n        }\n        // Otherwise we need to byteswap\n        return new Int64(byteswap64(big));\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n}\n\nAccumulator.prototype.readInt = function(bytes) {\n  var ival = this.peekInt(bytes);\n  if (ival instanceof Int64 && isFinite(ival.valueOf())) {\n    ival = ival.valueOf();\n  }\n  this.readOffset += bytes;\n  return ival;\n}\n\nAccumulator.prototype.peekDouble = function() {\n  this.assertReadableSize(8);\n  return isBigEndian ?\n    this.buf.readDoubleBE(this.readOffset) :\n    this.buf.readDoubleLE(this.readOffset);\n}\n\nAccumulator.prototype.readDouble = function() {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n}\n\nAccumulator.prototype.readAdvance = function(size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size +\n        \" would seek off the start of the buffer\");\n  }\n  this.readOffset += size;\n}\n\nAccumulator.prototype.writeByte = function(value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n}\n\nAccumulator.prototype.writeInt = function(value, size) {\n  this.reserve(size);\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n      break;\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n      break;\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n  this.writeOffset += size;\n}\n\nAccumulator.prototype.writeDouble = function(value) {\n  this.reserve(8);\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n  this.writeOffset += 8;\n}\n\nvar BSER_ARRAY     = 0x00;\nvar BSER_OBJECT    = 0x01;\nvar BSER_STRING    = 0x02;\nvar BSER_INT8      = 0x03;\nvar BSER_INT16     = 0x04;\nvar BSER_INT32     = 0x05;\nvar BSER_INT64     = 0x06;\nvar BSER_REAL      = 0x07;\nvar BSER_TRUE      = 0x08;\nvar BSER_FALSE     = 0x09;\nvar BSER_NULL      = 0x0a;\nvar BSER_TEMPLATE  = 0x0b;\nvar BSER_SKIP      = 0x0c;\n\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32767;\nvar MAX_INT32 = 2147483647;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function(buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n  // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n  this.processLater();\n}\n\nBunserBuf.prototype.processLater = function() {\n  var self = this;\n  process.nextTick(function() {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}\n\n// Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\nBunserBuf.prototype.process = function(synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    }\n    // Validate BSER header\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true /* relaxed */);\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    }\n    // Ensure that we have a big enough buffer to read the rest of the PDU\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    }\n\n    // We have enough to decode it\n    var val = this.decodeAny();\n    if (synchronous) {\n      return val;\n    }\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n}\n\nBunserBuf.prototype.raise = function(reason) {\n  throw new Error(reason + \", in Buffer of length \" +\n      this.buf.buf.length + \" (\" + this.buf.readAvail() +\n      \" readable) at offset \" + this.buf.readOffset + \" buffer: \" +\n      JSON.stringify(this.buf.buf.slice(\n          this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n}\n\nBunserBuf.prototype.expectCode = function(expected) {\n  var code = this.buf.readInt(1);\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeAny = function() {\n  var code = this.buf.peekInt(1);\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n    case BSER_STRING:\n      return this.decodeString();\n    case BSER_ARRAY:\n      return this.decodeArray();\n    case BSER_OBJECT:\n      return this.decodeObject();\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeArray = function() {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeObject = function() {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n  return res;\n}\n\nBunserBuf.prototype.decodeTemplate = function() {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n    arr.push(obj);\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeString = function() {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}\n\n// This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\nBunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1)) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n  var code = this.buf.peekInt(1);\n  var size = 0;\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n    case BSER_INT16:\n      size = 2;\n      break;\n    case BSER_INT32:\n      size = 4;\n      break;\n    case BSER_INT64:\n      size = 8;\n      break;\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1 + size)) {\n    return false;\n  }\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}\n\n// synchronously BSER decode a string and return the value\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n  if (buf.buf.readAvail()) {\n    throw Error(\n        'excess data found after input buffer, use BunserBuf instead');\n  }\n  if (typeof result === 'undefined') {\n    throw Error(\n        'no bser found in string and no error raised!?');\n  }\n  return result;\n}\nexports.loadFromBuffer = loadFromBuffer\n\n// Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\nfunction byteswap64(buf) {\n  var swap = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length -1 - i];\n  }\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  }\n  // We need to byte swap to get the correct representation\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof(val)) {\n    case 'number':\n      // check if it is an integer or a float\n      if (isFinite(val) && Math.floor(val) === val) {\n        dump_int(buf, val);\n      } else {\n        buf.writeByte(BSER_REAL);\n        buf.writeDouble(val);\n      }\n      return;\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n        return;\n      }\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val);\n\n      // First pass to compute number of defined keys\n      var num_keys = keys.length;\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          num_keys--;\n        }\n      }\n      dump_int(buf, num_keys);\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          // Don't include it\n          continue;\n        }\n        dump_any(buf, key);\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(\n            e.message + ' (while serializing object property with name `' +\n              key + \"')\");\n        }\n      }\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof(val) + ' to BSER');\n  }\n}\n\n// BSER encode value and return a buffer of the contents\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator();\n  // Build out the header\n  buf.writeByte(0);\n  buf.writeByte(1);\n  // Reserve room for an int32 to hold our PDU length\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val);\n\n  // Compute PDU length\n  var off = buf.writeOffset;\n  var len = off - 7 /* the header length */;\n  buf.writeOffset = 3; // The length value to fill in\n  buf.writeInt(len, 4); // write the length in the space we reserved\n  buf.writeOffset = off;\n\n  return buf.buf.slice(0, off);\n}\nexports.dumpToBuffer = dumpToBuffer\n"]},"metadata":{},"sourceType":"script"}