{"ast":null,"code":"/* Copyright 2014-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n'use strict';\n\nvar net = require('net');\n\nvar EE = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar childProcess = require('child_process');\n\nvar bser = require('bser'); // We'll emit the responses to these when they get sent down to us\n\n\nvar unilateralTags = ['subscription', 'log'];\n/**\n * @param options An object with the following optional keys:\n *   * 'watchmanBinaryPath' (string) Absolute path to the watchman binary.\n *     If not provided, the Client locates the binary using the PATH specified\n *     by the node child_process's default env.\n */\n\nfunction Client(options) {\n  var self = this;\n  EE.call(this);\n  this.watchmanBinaryPath = 'watchman';\n\n  if (options && options.watchmanBinaryPath) {\n    this.watchmanBinaryPath = options.watchmanBinaryPath.trim();\n  }\n\n  ;\n  this.commands = [];\n}\n\nutil.inherits(Client, EE);\nmodule.exports.Client = Client; // Try to send the next queued command, if any\n\nClient.prototype.sendNextCommand = function () {\n  if (this.currentCommand) {\n    // There's a command pending response, don't send this new one yet\n    return;\n  }\n\n  this.currentCommand = this.commands.shift();\n\n  if (!this.currentCommand) {\n    // No further commands are queued\n    return;\n  }\n\n  this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));\n};\n\nClient.prototype.cancelCommands = function (why) {\n  var error = new Error(why); // Steal all pending commands before we start cancellation, in\n  // case something decides to schedule more commands\n\n  var cmds = this.commands;\n  this.commands = [];\n\n  if (this.currentCommand) {\n    cmds.unshift(this.currentCommand);\n    this.currentCommand = null;\n  } // Synthesize an error condition for any commands that were queued\n\n\n  cmds.forEach(function (cmd) {\n    cmd.cb(error);\n  });\n};\n\nClient.prototype.connect = function () {\n  var self = this;\n\n  function makeSock(sockname) {\n    // bunser will decode the watchman BSER protocol for us\n    self.bunser = new bser.BunserBuf(); // For each decoded line:\n\n    self.bunser.on('value', function (obj) {\n      // Figure out if this is a unliteral response or if it is the\n      // response portion of a request-response sequence.  At the time\n      // of writing, there are only two possible unilateral responses.\n      var unilateral = false;\n\n      for (var i = 0; i < unilateralTags.length; i++) {\n        var tag = unilateralTags[i];\n\n        if (tag in obj) {\n          unilateral = tag;\n        }\n      }\n\n      if (unilateral) {\n        self.emit(unilateral, obj);\n      } else if (self.currentCommand) {\n        var cmd = self.currentCommand;\n        self.currentCommand = null;\n\n        if ('error' in obj) {\n          var error = new Error(obj.error);\n          error.watchmanResponse = obj;\n          cmd.cb(error);\n        } else {\n          cmd.cb(null, obj);\n        }\n      } // See if we can dispatch the next queued command, if any\n\n\n      self.sendNextCommand();\n    });\n    self.bunser.on('error', function (err) {\n      self.emit('error', err);\n    });\n    self.socket = net.createConnection(sockname);\n    self.socket.on('connect', function () {\n      self.connecting = false;\n      self.emit('connect');\n      self.sendNextCommand();\n    });\n    self.socket.on('error', function (err) {\n      self.connecting = false;\n      self.emit('error', err);\n    });\n    self.socket.on('data', function (buf) {\n      if (self.bunser) {\n        self.bunser.append(buf);\n      }\n    });\n    self.socket.on('end', function () {\n      self.socket = null;\n      self.bunser = null;\n      self.cancelCommands('The watchman connection was closed');\n      self.emit('end');\n    });\n  } // triggers will export the sock path to the environment.\n  // If we're invoked in such a way, we can simply pick up the\n  // definition from the environment and avoid having to fork off\n  // a process to figure it out\n\n\n  if (process.env.WATCHMAN_SOCK) {\n    makeSock(process.env.WATCHMAN_SOCK);\n    return;\n  } // We need to ask the client binary where to find it.\n  // This will cause the service to start for us if it isn't\n  // already running.\n\n\n  var args = ['--no-pretty', 'get-sockname']; // We use the more elaborate spawn rather than exec because there\n  // are some error cases on Windows where process spawning can hang.\n  // It is desirable to pipe stderr directly to stderr live so that\n  // we can discover the problem.\n\n  var proc = null;\n  var spawnFailed = false;\n\n  function spawnError(error) {\n    if (spawnFailed) {\n      // For ENOENT, proc 'close' will also trigger with a negative code,\n      // let's suppress that second error.\n      return;\n    }\n\n    spawnFailed = true;\n\n    if (error.errno === 'EACCES') {\n      error.message = 'The Watchman CLI is installed but cannot ' + 'be spawned because of a permission problem';\n    } else if (error.errno === 'ENOENT') {\n      error.message = 'Watchman was not found in PATH.  See ' + 'https://facebook.github.io/watchman/docs/install.html ' + 'for installation instructions';\n    }\n\n    console.error('Watchman: ', error.message);\n    self.emit('error', error);\n  }\n\n  try {\n    proc = childProcess.spawn(this.watchmanBinaryPath, args, {\n      stdio: ['ignore', 'pipe', 'pipe']\n    });\n  } catch (error) {\n    spawnError(error);\n    return;\n  }\n\n  var stdout = [];\n  var stderr = [];\n  proc.stdout.on('data', function (data) {\n    stdout.push(data);\n  });\n  proc.stderr.on('data', function (data) {\n    data = data.toString('utf8');\n    stderr.push(data);\n    console.error(data);\n  });\n  proc.on('error', function (error) {\n    spawnError(error);\n  });\n  proc.on('close', function (code, signal) {\n    if (code !== 0) {\n      spawnError(new Error(self.watchmanBinaryPath + ' ' + args.join(' ') + ' returned with exit code=' + code + ', signal=' + signal + ', stderr= ' + stderr.join('')));\n      return;\n    }\n\n    try {\n      var obj = JSON.parse(stdout.join(''));\n\n      if ('error' in obj) {\n        var error = new Error(obj.error);\n        error.watchmanResponse = obj;\n        self.emit('error', error);\n        return;\n      }\n\n      makeSock(obj.sockname);\n    } catch (e) {\n      self.emit('error', e);\n    }\n  });\n};\n\nClient.prototype.command = function (args, done) {\n  done = done || function () {}; // Queue up the command\n\n\n  this.commands.push({\n    cmd: args,\n    cb: done\n  }); // Establish a connection if we don't already have one\n\n  if (!this.socket) {\n    if (!this.connecting) {\n      this.connecting = true;\n      this.connect();\n      return;\n    }\n\n    return;\n  } // If we're already connected and idle, try sending the command immediately\n\n\n  this.sendNextCommand();\n};\n\nvar cap_versions = {\n  \"cmd-watch-del-all\": \"3.1.1\",\n  \"cmd-watch-project\": \"3.1\",\n  \"relative_root\": \"3.3\",\n  \"term-dirname\": \"3.1\",\n  \"term-idirname\": \"3.1\",\n  \"wildmatch\": \"3.7\"\n}; // Compares a vs b, returns < 0 if a < b, > 0 if b > b, 0 if a == b\n\nfunction vers_compare(a, b) {\n  a = a.split('.');\n  b = b.split('.');\n\n  for (var i = 0; i < 3; i++) {\n    var d = parseInt(a[i] || '0') - parseInt(b[i] || '0');\n\n    if (d != 0) {\n      return d;\n    }\n  }\n\n  return 0; // Equal\n}\n\nfunction have_cap(vers, name) {\n  if (name in cap_versions) {\n    return vers_compare(vers, cap_versions[name]) >= 0;\n  }\n\n  return false;\n} // This is a helper that we expose for testing purposes\n\n\nClient.prototype._synthesizeCapabilityCheck = function (resp, optional, required) {\n  resp.capabilities = {};\n  var version = resp.version;\n  optional.forEach(function (name) {\n    resp.capabilities[name] = have_cap(version, name);\n  });\n  required.forEach(function (name) {\n    var have = have_cap(version, name);\n    resp.capabilities[name] = have;\n\n    if (!have) {\n      resp.error = 'client required capability `' + name + '` is not supported by this server';\n    }\n  });\n  return resp;\n};\n\nClient.prototype.capabilityCheck = function (caps, done) {\n  var optional = caps.optional || [];\n  var required = caps.required || [];\n  var self = this;\n  this.command(['version', {\n    optional: optional,\n    required: required\n  }], function (error, resp) {\n    if (error) {\n      done(error);\n      return;\n    }\n\n    if (!('capabilities' in resp)) {\n      // Server doesn't support capabilities, so we need to\n      // synthesize the results based on the version\n      resp = self._synthesizeCapabilityCheck(resp, optional, required);\n\n      if (resp.error) {\n        error = new Error(resp.error);\n        error.watchmanResponse = resp;\n        done(error);\n        return;\n      }\n    }\n\n    done(null, resp);\n  });\n}; // Close the connection to the service\n\n\nClient.prototype.end = function () {\n  this.cancelCommands('The client was ended');\n\n  if (this.socket) {\n    this.socket.end();\n    this.socket = null;\n  }\n\n  this.bunser = null;\n};","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/fb-watchman/index.js"],"names":["net","require","EE","EventEmitter","util","childProcess","bser","unilateralTags","Client","options","self","call","watchmanBinaryPath","trim","commands","inherits","module","exports","prototype","sendNextCommand","currentCommand","shift","socket","write","dumpToBuffer","cmd","cancelCommands","why","error","Error","cmds","unshift","forEach","cb","connect","makeSock","sockname","bunser","BunserBuf","on","obj","unilateral","i","length","tag","emit","watchmanResponse","err","createConnection","connecting","buf","append","process","env","WATCHMAN_SOCK","args","proc","spawnFailed","spawnError","errno","message","console","spawn","stdio","stdout","stderr","data","push","toString","code","signal","join","JSON","parse","e","command","done","cap_versions","vers_compare","a","b","split","d","parseInt","have_cap","vers","name","_synthesizeCapabilityCheck","resp","optional","required","capabilities","version","have","capabilityCheck","caps","end"],"mappings":"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","sourcesContent":["/* Copyright 2014-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\n'use strict';\n\nvar net = require('net');\nvar EE = require('events').EventEmitter;\nvar util = require('util');\nvar childProcess = require('child_process');\nvar bser = require('bser');\n\n// We'll emit the responses to these when they get sent down to us\nvar unilateralTags = ['subscription', 'log'];\n\n/**\n * @param options An object with the following optional keys:\n *   * 'watchmanBinaryPath' (string) Absolute path to the watchman binary.\n *     If not provided, the Client locates the binary using the PATH specified\n *     by the node child_process's default env.\n */\nfunction Client(options) {\n  var self = this;\n  EE.call(this);\n\n  this.watchmanBinaryPath = 'watchman';\n  if (options && options.watchmanBinaryPath) {\n    this.watchmanBinaryPath = options.watchmanBinaryPath.trim();\n  };\n  this.commands = [];\n}\nutil.inherits(Client, EE);\n\nmodule.exports.Client = Client;\n\n// Try to send the next queued command, if any\nClient.prototype.sendNextCommand = function() {\n  if (this.currentCommand) {\n    // There's a command pending response, don't send this new one yet\n    return;\n  }\n\n  this.currentCommand = this.commands.shift();\n  if (!this.currentCommand) {\n    // No further commands are queued\n    return;\n  }\n\n  this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));\n}\n\nClient.prototype.cancelCommands = function(why) {\n  var error = new Error(why);\n\n  // Steal all pending commands before we start cancellation, in\n  // case something decides to schedule more commands\n  var cmds = this.commands;\n  this.commands = [];\n\n  if (this.currentCommand) {\n    cmds.unshift(this.currentCommand);\n    this.currentCommand = null;\n  }\n\n  // Synthesize an error condition for any commands that were queued\n  cmds.forEach(function(cmd) {\n    cmd.cb(error);\n  });\n}\n\nClient.prototype.connect = function() {\n  var self = this;\n\n  function makeSock(sockname) {\n    // bunser will decode the watchman BSER protocol for us\n    self.bunser = new bser.BunserBuf();\n    // For each decoded line:\n    self.bunser.on('value', function(obj) {\n      // Figure out if this is a unliteral response or if it is the\n      // response portion of a request-response sequence.  At the time\n      // of writing, there are only two possible unilateral responses.\n      var unilateral = false;\n      for (var i = 0; i < unilateralTags.length; i++) {\n        var tag = unilateralTags[i];\n        if (tag in obj) {\n          unilateral = tag;\n        }\n      }\n\n      if (unilateral) {\n        self.emit(unilateral, obj);\n      } else if (self.currentCommand) {\n        var cmd = self.currentCommand;\n        self.currentCommand = null;\n        if ('error' in obj) {\n          var error = new Error(obj.error);\n          error.watchmanResponse = obj;\n          cmd.cb(error);\n        } else {\n          cmd.cb(null, obj);\n        }\n      }\n\n      // See if we can dispatch the next queued command, if any\n      self.sendNextCommand();\n    });\n    self.bunser.on('error', function(err) {\n      self.emit('error', err);\n    });\n\n    self.socket = net.createConnection(sockname);\n    self.socket.on('connect', function() {\n      self.connecting = false;\n      self.emit('connect');\n      self.sendNextCommand();\n    });\n    self.socket.on('error', function(err) {\n      self.connecting = false;\n      self.emit('error', err);\n    });\n    self.socket.on('data', function(buf) {\n      if (self.bunser) {\n        self.bunser.append(buf);\n      }\n    });\n    self.socket.on('end', function() {\n      self.socket = null;\n      self.bunser = null;\n      self.cancelCommands('The watchman connection was closed');\n      self.emit('end');\n    });\n  }\n\n  // triggers will export the sock path to the environment.\n  // If we're invoked in such a way, we can simply pick up the\n  // definition from the environment and avoid having to fork off\n  // a process to figure it out\n  if (process.env.WATCHMAN_SOCK) {\n    makeSock(process.env.WATCHMAN_SOCK);\n    return;\n  }\n\n  // We need to ask the client binary where to find it.\n  // This will cause the service to start for us if it isn't\n  // already running.\n  var args = ['--no-pretty', 'get-sockname'];\n\n  // We use the more elaborate spawn rather than exec because there\n  // are some error cases on Windows where process spawning can hang.\n  // It is desirable to pipe stderr directly to stderr live so that\n  // we can discover the problem.\n  var proc = null;\n  var spawnFailed = false;\n\n  function spawnError(error) {\n    if (spawnFailed) {\n      // For ENOENT, proc 'close' will also trigger with a negative code,\n      // let's suppress that second error.\n      return;\n    }\n    spawnFailed = true;\n    if (error.errno === 'EACCES') {\n      error.message = 'The Watchman CLI is installed but cannot ' +\n                      'be spawned because of a permission problem';\n    } else if (error.errno === 'ENOENT') {\n      error.message = 'Watchman was not found in PATH.  See ' +\n          'https://facebook.github.io/watchman/docs/install.html ' +\n          'for installation instructions';\n    }\n    console.error('Watchman: ', error.message);\n    self.emit('error', error);\n  }\n\n  try {\n    proc = childProcess.spawn(this.watchmanBinaryPath, args, {\n      stdio: ['ignore', 'pipe', 'pipe']\n    });\n  } catch (error) {\n    spawnError(error);\n    return;\n  }\n\n  var stdout = [];\n  var stderr = [];\n  proc.stdout.on('data', function(data) {\n    stdout.push(data);\n  });\n  proc.stderr.on('data', function(data) {\n    data = data.toString('utf8');\n    stderr.push(data);\n    console.error(data);\n  });\n  proc.on('error', function(error) {\n    spawnError(error);\n  });\n\n  proc.on('close', function (code, signal) {\n    if (code !== 0) {\n      spawnError(new Error(\n          self.watchmanBinaryPath + ' ' + args.join(' ') +\n          ' returned with exit code=' + code + ', signal=' +\n          signal + ', stderr= ' + stderr.join('')));\n      return;\n    }\n    try {\n      var obj = JSON.parse(stdout.join(''));\n      if ('error' in obj) {\n        var error = new Error(obj.error);\n        error.watchmanResponse = obj;\n        self.emit('error', error);\n        return;\n      }\n      makeSock(obj.sockname);\n    } catch (e) {\n      self.emit('error', e);\n    }\n  });\n}\n\nClient.prototype.command = function(args, done) {\n  done = done || function() {};\n\n  // Queue up the command\n  this.commands.push({cmd: args, cb: done});\n\n  // Establish a connection if we don't already have one\n  if (!this.socket) {\n    if (!this.connecting) {\n      this.connecting = true;\n      this.connect();\n      return;\n    }\n    return;\n  }\n\n  // If we're already connected and idle, try sending the command immediately\n  this.sendNextCommand();\n}\n\nvar cap_versions = {\n    \"cmd-watch-del-all\": \"3.1.1\",\n    \"cmd-watch-project\": \"3.1\",\n    \"relative_root\": \"3.3\",\n    \"term-dirname\": \"3.1\",\n    \"term-idirname\": \"3.1\",\n    \"wildmatch\": \"3.7\",\n}\n\n// Compares a vs b, returns < 0 if a < b, > 0 if b > b, 0 if a == b\nfunction vers_compare(a, b) {\n  a = a.split('.');\n  b = b.split('.');\n  for (var i = 0; i < 3; i++) {\n    var d = parseInt(a[i] || '0') - parseInt(b[i] || '0');\n    if (d != 0) {\n      return d;\n    }\n  }\n  return 0; // Equal\n}\n\nfunction have_cap(vers, name) {\n  if (name in cap_versions) {\n    return vers_compare(vers, cap_versions[name]) >= 0;\n  }\n  return false;\n}\n\n// This is a helper that we expose for testing purposes\nClient.prototype._synthesizeCapabilityCheck = function(\n    resp, optional, required) {\n  resp.capabilities = {}\n  var version = resp.version;\n  optional.forEach(function (name) {\n    resp.capabilities[name] = have_cap(version, name);\n  });\n  required.forEach(function (name) {\n    var have = have_cap(version, name);\n    resp.capabilities[name] = have;\n    if (!have) {\n      resp.error = 'client required capability `' + name +\n                   '` is not supported by this server';\n    }\n  });\n  return resp;\n}\n\nClient.prototype.capabilityCheck = function(caps, done) {\n  var optional = caps.optional || [];\n  var required = caps.required || [];\n  var self = this;\n  this.command(['version', {\n      optional: optional,\n      required: required\n  }], function (error, resp) {\n    if (error) {\n      done(error);\n      return;\n    }\n    if (!('capabilities' in resp)) {\n      // Server doesn't support capabilities, so we need to\n      // synthesize the results based on the version\n      resp = self._synthesizeCapabilityCheck(resp, optional, required);\n      if (resp.error) {\n        error = new Error(resp.error);\n        error.watchmanResponse = resp;\n        done(error);\n        return;\n      }\n    }\n    done(null, resp);\n  });\n}\n\n// Close the connection to the service\nClient.prototype.end = function() {\n  this.cancelCommands('The client was ended');\n  if (this.socket) {\n    this.socket.end();\n    this.socket = null;\n  }\n  this.bunser = null;\n}\n"]},"metadata":{},"sourceType":"script"}