{"ast":null,"code":"// Copyright 2010-2011 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\nvar sys = require('util'),\n    fs = require('fs'),\n    path = require('path'),\n    events = require('events');\n\nfunction walk(dir, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!callback.files) callback.files = {};\n  if (!callback.pending) callback.pending = 0;\n  callback.pending += 1;\n  fs.stat(dir, function (err, stat) {\n    if (err) return callback(err);\n    callback.files[dir] = stat;\n    fs.readdir(dir, function (err, files) {\n      if (err) {\n        if (err.code === 'EACCES' && options.ignoreUnreadableDir) return callback();\n        return callback(err);\n      }\n\n      callback.pending -= 1;\n      files.forEach(function (f, index) {\n        f = path.join(dir, f);\n        callback.pending += 1;\n        fs.stat(f, function (err, stat) {\n          var enoent = false,\n              done = false;\n\n          if (err) {\n            if (err.code !== 'ENOENT' && err.code !== 'EPERM' && options.ignoreNotPermitted) {\n              return callback(err);\n            } else {\n              enoent = true;\n            }\n          }\n\n          callback.pending -= 1;\n          done = callback.pending === 0;\n\n          if (!enoent) {\n            if (options.ignoreDotFiles && path.basename(f)[0] === '.') return done && callback(null, callback.files);\n            if (options.filter && !options.filter(f, stat)) return done && callback(null, callback.files);\n            callback.files[f] = stat;\n            if (stat.isDirectory() && !(options.ignoreDirectoryPattern && options.ignoreDirectoryPattern.test(f))) walk(f, options, callback);\n            done = callback.pending === 0;\n            if (done) callback(null, callback.files);\n          }\n        });\n      });\n      if (callback.pending === 0) callback(null, callback.files);\n    });\n    if (callback.pending === 0) callback(null, callback.files);\n  });\n}\n\nvar watchedFiles = Object.create(null);\n\nexports.watchTree = function (root, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  walk(root, options, function (err, files) {\n    if (err) throw err;\n\n    var fileWatcher = function (f) {\n      var fsOptions = {};\n\n      if (options.interval) {\n        fsOptions.interval = options.interval * 1000;\n      }\n\n      fs.watchFile(f, fsOptions, function (c, p) {\n        // Check if anything actually changed in stat\n        if (files[f] && !files[f].isDirectory() && c.nlink !== 0 && files[f].mtime.getTime() == c.mtime.getTime()) return;\n        files[f] = c;\n        if (!files[f].isDirectory()) callback(f, c, p);else {\n          fs.readdir(f, function (err, nfiles) {\n            if (err) return;\n            nfiles.forEach(function (b) {\n              var file = path.join(f, b);\n\n              if (!files[file] && (options.ignoreDotFiles !== true || b[0] != '.')) {\n                fs.stat(file, function (err, stat) {\n                  if (options.filter && !options.filter(file, stat)) return;\n                  callback(file, stat, null);\n                  files[file] = stat;\n                  fileWatcher(file);\n                });\n              }\n            });\n          });\n        }\n\n        if (c.nlink === 0) {\n          // unwatch removed files.\n          delete files[f];\n          fs.unwatchFile(f);\n        }\n      });\n    };\n\n    fileWatcher(root);\n\n    for (var i in files) {\n      fileWatcher(i);\n    }\n\n    watchedFiles[root] = files;\n    callback(files, null, null);\n  });\n};\n\nexports.unwatchTree = function (root) {\n  if (!watchedFiles[root]) return;\n  Object.keys(watchedFiles[root]).forEach(fs.unwatchFile);\n  watchedFiles[root] = false;\n};\n\nexports.createMonitor = function (root, options, cb) {\n  if (!cb) {\n    cb = options;\n    options = {};\n  }\n\n  var monitor = new events.EventEmitter();\n  monitor.stop = exports.unwatchTree.bind(null, root);\n  var prevFile = {\n    file: null,\n    action: null,\n    stat: null\n  };\n  exports.watchTree(root, options, function (f, curr, prev) {\n    // if not curr, prev, but f is an object\n    if (typeof f == \"object\" && prev == null && curr === null) {\n      monitor.files = f;\n      return cb(monitor);\n    } // if not prev and either prevFile.file is not f or prevFile.action is not created\n\n\n    if (!prev) {\n      if (prevFile.file != f || prevFile.action != \"created\") {\n        prevFile = {\n          file: f,\n          action: \"created\",\n          stat: curr\n        };\n        return monitor.emit(\"created\", f, curr);\n      }\n    } // if curr.nlink is 0 and either prevFile.file is not f or prevFile.action is not removed\n\n\n    if (curr) {\n      if (curr.nlink === 0) {\n        if (prevFile.file != f || prevFile.action != \"removed\") {\n          prevFile = {\n            file: f,\n            action: \"removed\",\n            stat: curr\n          };\n          return monitor.emit(\"removed\", f, curr);\n        }\n      }\n    } // if prevFile.file is null or prevFile.stat.mtime is not the same as curr.mtime\n\n\n    if (prevFile.file === null) {\n      return monitor.emit(\"changed\", f, curr, prev);\n    } // stat might return null, so catch errors\n\n\n    try {\n      if (prevFile.stat.mtime.getTime() !== curr.mtime.getTime()) {\n        return monitor.emit(\"changed\", f, curr, prev);\n      }\n    } catch (e) {\n      return monitor.emit(\"changed\", f, curr, prev);\n    }\n  });\n};\n\nexports.walk = walk;","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/@cnakazawa/watch/main.js"],"names":["sys","require","fs","path","events","walk","dir","options","callback","files","pending","stat","err","readdir","code","ignoreUnreadableDir","forEach","f","index","join","enoent","done","ignoreNotPermitted","ignoreDotFiles","basename","filter","isDirectory","ignoreDirectoryPattern","test","watchedFiles","Object","create","exports","watchTree","root","fileWatcher","fsOptions","interval","watchFile","c","p","nlink","mtime","getTime","nfiles","b","file","unwatchFile","i","unwatchTree","keys","createMonitor","cb","monitor","EventEmitter","stop","bind","prevFile","action","curr","prev","emit","e"],"mappings":"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","sourcesContent":["// Copyright 2010-2011 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\nvar sys = require('util')\n  , fs = require('fs')\n  , path = require('path')\n  , events = require('events')\n  ;\n\nfunction walk (dir, options, callback) {\n  if (!callback) {callback = options; options = {}}\n  if (!callback.files) callback.files = {};\n  if (!callback.pending) callback.pending = 0;\n  callback.pending += 1;\n  fs.stat(dir, function (err, stat) {\n    if (err) return callback(err);\n    callback.files[dir] = stat;\n    fs.readdir(dir, function (err, files) {\n      if (err) {\n        if(err.code === 'EACCES' && options.ignoreUnreadableDir) return callback();\n        return callback(err);\n      }\n      callback.pending -= 1;\n      files.forEach(function (f, index) {\n        f = path.join(dir, f);\n        callback.pending += 1;\n        fs.stat(f, function (err, stat) {\n          var enoent = false\n            , done = false;\n\n          if (err) {\n            if (err.code !== 'ENOENT' && (err.code !== 'EPERM' && options.ignoreNotPermitted)) {\n              return callback(err);\n            } else {\n              enoent = true;\n            }\n          }\n          callback.pending -= 1;\n          done = callback.pending === 0;\n          if (!enoent) {\n            if (options.ignoreDotFiles && path.basename(f)[0] === '.') return done && callback(null, callback.files);\n            if (options.filter && !options.filter(f, stat)) return done && callback(null, callback.files);\n            callback.files[f] = stat;\n            if (stat.isDirectory() && !(options.ignoreDirectoryPattern && options.ignoreDirectoryPattern.test(f))) walk(f, options, callback);\n            done = callback.pending === 0;\n            if (done) callback(null, callback.files);\n          }\n        })\n      })\n      if (callback.pending === 0) callback(null, callback.files);\n    })\n    if (callback.pending === 0) callback(null, callback.files);\n  })\n\n}\n\nvar watchedFiles = Object.create(null);\n\nexports.watchTree = function ( root, options, callback ) {\n  if (!callback) {callback = options; options = {}}\n  walk(root, options, function (err, files) {\n    if (err) throw err;\n    var fileWatcher = function (f) {\n      var fsOptions = {};\n      if (options.interval) {\n        fsOptions.interval = options.interval * 1000;\n      }\n      fs.watchFile(f, fsOptions, function (c, p) {\n        // Check if anything actually changed in stat\n        if (files[f] && !files[f].isDirectory() && c.nlink !== 0 && files[f].mtime.getTime() == c.mtime.getTime()) return;\n        files[f] = c;\n        if (!files[f].isDirectory()) callback(f, c, p);\n        else {\n          fs.readdir(f, function (err, nfiles) {\n            if (err) return;\n            nfiles.forEach(function (b) {\n              var file = path.join(f, b);\n              if (!files[file] && (options.ignoreDotFiles !== true || b[0] != '.')) {\n                fs.stat(file, function (err, stat) {\n                  if (options.filter && !options.filter(file, stat)) return;\n                  callback(file, stat, null);\n                  files[file] = stat;\n                  fileWatcher(file);\n                })\n              }\n            })\n          })\n        }\n        if (c.nlink === 0) {\n          // unwatch removed files.\n          delete files[f]\n          fs.unwatchFile(f);\n        }\n      })\n    }\n    fileWatcher(root);\n    for (var i in files) {\n      fileWatcher(i);\n    }\n    watchedFiles[root] = files;\n    callback(files, null, null);\n  })\n}\n\nexports.unwatchTree = function (root) {\n  if (!watchedFiles[root]) return;\n  Object.keys(watchedFiles[root]).forEach(fs.unwatchFile);\n  watchedFiles[root] = false;\n};\n\nexports.createMonitor = function (root, options, cb) {\n  if (!cb) {cb = options; options = {}}\n  var monitor = new events.EventEmitter();\n  monitor.stop = exports.unwatchTree.bind(null, root);\n\n  var prevFile = {file: null,action: null,stat: null};\n  exports.watchTree(root, options, function (f, curr, prev) {\n    // if not curr, prev, but f is an object\n    if (typeof f == \"object\" && prev == null && curr === null) {\n      monitor.files = f;\n      return cb(monitor);\n    }\n\n    // if not prev and either prevFile.file is not f or prevFile.action is not created\n    if (!prev) {\n      if (prevFile.file != f || prevFile.action != \"created\") {\n        prevFile = { file: f, action: \"created\", stat: curr };\n        return monitor.emit(\"created\", f, curr);\n      }\n    }\n\n    // if curr.nlink is 0 and either prevFile.file is not f or prevFile.action is not removed\n    if (curr) {\n      if (curr.nlink === 0) {\n        if (prevFile.file != f || prevFile.action != \"removed\") {\n          prevFile = { file: f, action: \"removed\", stat: curr };\n          return monitor.emit(\"removed\", f, curr);\n        }\n      }\n    }\n\n    // if prevFile.file is null or prevFile.stat.mtime is not the same as curr.mtime\n    if (prevFile.file === null) {\n      return monitor.emit(\"changed\", f, curr, prev);\n    }\n    // stat might return null, so catch errors\n    try {\n      if (prevFile.stat.mtime.getTime() !== curr.mtime.getTime()) {\n        return monitor.emit(\"changed\", f, curr, prev);\n      }\n    } catch(e) {\n      return monitor.emit(\"changed\", f, curr, prev);\n    }\n  })\n}\n\nexports.walk = walk;\n"]},"metadata":{},"sourceType":"script"}