{"ast":null,"code":"'use strict';\n\nconst watchman = require('fb-watchman');\n\nconst captureExit = require('capture-exit');\n\nfunction values(obj) {\n  return Object.keys(obj).map(key => obj[key]);\n}\n/**\n * Constants\n */\n\n/**\n * Singleton that provides a public API for a connection to a watchman instance for 'sane'.\n * It tries to abstract/remove as much of the boilerplate processing as necessary\n * from WatchmanWatchers that use it. In particular, they have no idea whether\n * we're using 'watch-project' or 'watch', what the 'project root' is when\n * we internally use watch-project, whether a connection has been lost\n * and reestablished, etc. Also switched to doing things with promises and known-name\n * methods in WatchmanWatcher, so as much information as possible can be kept in\n * the WatchmanClient, ultimately making this the only object listening directly\n * to watchman.Client, then forwarding appropriately (via the known-name methods) to\n * the relevant WatchmanWatcher(s).\n *\n * Note: WatchmanWatcher also added a 'watchmanPath' option for use with the sane CLI.\n * Because of that, we actually need a map of watchman binary path to WatchmanClient instance.\n * That is set up in getInstance(). Once the WatchmanWatcher has a given client, it doesn't\n * change.\n *\n * @class WatchmanClient\n * @param String watchmanBinaryPath\n * @public\n */\n\n\nclass WatchmanClient {\n  constructor(watchmanBinaryPath) {\n    captureExit.captureExit(); // define/clear some local state. The properties will be initialized\n    // in _handleClientAndCheck(). This is also called again in _onEnd when\n    // trying to reestablish connection to watchman.\n\n    this._clearLocalVars();\n\n    this._watchmanBinaryPath = watchmanBinaryPath;\n    this._backoffTimes = this._setupBackoffTimes();\n    this._clientListeners = null; // direct listeners from here to watchman.Client.\n    // Define a handler for if somehow the Node process gets interrupted. We need to\n    // close down the watchman.Client, if we have one.\n\n    captureExit.onExit(() => this._clearLocalVars());\n  } // Define 'wildmatch' property, which must be available when we call the\n  // WatchmanWatcher.createOptions() method.\n\n\n  get wildmatch() {\n    return this._wildmatch;\n  }\n  /**\n   * Called from WatchmanWatcher (or WatchmanClient during reconnect) to create\n   * a watcherInfo entry in our _watcherMap and issue a 'subscribe' to the\n   * watchman.Client, to be handled here.\n   */\n\n\n  subscribe(watchmanWatcher, root) {\n    let subscription;\n    let watcherInfo;\n    return this._setupClient().then(() => {\n      watcherInfo = this._createWatcherInfo(watchmanWatcher);\n      subscription = watcherInfo.subscription;\n      return this._watch(subscription, root);\n    }).then(() => this._clock(subscription)).then(() => this._subscribe(subscription)); // Note: callers are responsible for noting any subscription failure.\n  }\n  /**\n   * Remove the information about a specific WatchmanWatcher.\n   * Once done, if no watchers are left, clear the local vars,\n   * which will end the connection to the watchman.Client, too.\n   */\n\n\n  closeWatcher(watchmanWatcher) {\n    let watcherInfos = values(this._watcherMap);\n    let numWatchers = watcherInfos.length;\n\n    if (numWatchers > 0) {\n      let watcherInfo;\n\n      for (let info of watcherInfos) {\n        if (info.watchmanWatcher === watchmanWatcher) {\n          watcherInfo = info;\n          break;\n        }\n      }\n\n      if (watcherInfo) {\n        delete this._watcherMap[watcherInfo.subscription];\n        numWatchers--;\n\n        if (numWatchers === 0) {\n          this._clearLocalVars(); // nobody watching, so shut the watchman.Client down.\n\n        }\n      }\n    }\n  }\n  /**\n   * Simple backoff-time iterator. next() returns times in ms.\n   * When it's at the last value, it stays there until reset()\n   * is called.\n   */\n\n\n  _setupBackoffTimes() {\n    return {\n      _times: [0, 1000, 5000, 10000, 60000],\n      _next: 0,\n\n      next() {\n        let val = this._times[this._next];\n\n        if (this._next < this._times.length - 1) {\n          this._next++;\n        }\n\n        return val;\n      },\n\n      reset() {\n        this._next = 0;\n      }\n\n    };\n  }\n  /**\n   * Set up the connection to the watchman client. Return a promise\n   * that is fulfilled when we have a client that has finished the\n   * capabilityCheck.\n   */\n\n\n  _setupClient() {\n    if (!this._clientPromise) {\n      this._clientPromise = new Promise((resolve, reject) => {\n        this._handleClientAndCheck(resolve, reject);\n      });\n    }\n\n    return this._clientPromise;\n  }\n  /**\n   * Handle the process of creating a client and doing a capability check and\n   * getting a valid response, then setting up local data based on that.\n   *\n   * This is split from _setupClient and _createClientAndCheck so it can\n   * provide the backoff handling needed during attempts to reconnect.\n   */\n\n\n  _handleClientAndCheck(resolve, reject) {\n    this._createClientAndCheck().then(value => {\n      let resp = value.resp;\n      let client = value.client;\n\n      try {\n        this._wildmatch = resp.capabilities.wildmatch;\n        this._relative_root = resp.capabilities.relative_root;\n        this._client = client;\n        client.on('subscription', this._onSubscription.bind(this));\n        client.on('error', this._onError.bind(this));\n        client.on('end', this._onEnd.bind(this));\n\n        this._backoffTimes.reset();\n\n        resolve(this);\n      } catch (error) {\n        // somehow, even though we supposedly got a valid value back, it's\n        // malformed, or some other internal error occurred. Reject so\n        // the promise itself doesn't hang forever.\n        reject(error);\n      }\n    }, () => {\n      // create & capability check failed in any of several ways,\n      // do the retry with backoff.\n      // XXX May want to change this later to actually reject/terminate with\n      // an error in certain of the inner errors (e.g. when we\n      // can figure out the server is definitely not coming\n      // back, or something else is not recoverable by just waiting).\n      // Could also decide after N retries to just quit.\n      let backoffMillis = this._backoffTimes.next(); // XXX may want to fact we'll attempt reconnect in backoffMillis ms.\n\n\n      setTimeout(() => {\n        this._handleClientAndCheck(resolve, reject);\n      }, backoffMillis);\n    });\n  }\n  /**\n   * Create a promise that will only be fulfilled when either\n   * we correctly get capabilities back or we get an 'error' or 'end'\n   * callback, indicating a problem. The caller _handleClientAndCheck\n   * then deals with providing a retry and backoff mechanism.\n   */\n\n\n  _createClientAndCheck() {\n    return new Promise((resolve, reject) => {\n      let client;\n\n      try {\n        client = new watchman.Client(this._watchmanBinaryPath ? {\n          watchmanBinaryPath: this._watchmanBinaryPath\n        } : {});\n      } catch (error) {\n        // if we're here, either the binary path is bad or something\n        // else really bad happened. The client doesn't even attempt\n        // to connect until we send it a command, though.\n        reject(error);\n        return;\n      }\n\n      client.on('error', error => {\n        client.removeAllListeners();\n        reject(error);\n      });\n      client.on('end', () => {\n        client.removeAllListeners();\n        reject(new Error('Disconnected during client capabilities check'));\n      });\n      client.capabilityCheck({\n        optional: ['wildmatch', 'relative_root']\n      }, (error, resp) => {\n        try {\n          client.removeAllListeners();\n\n          if (error) {\n            reject(error);\n          } else {\n            resolve({\n              resp,\n              client\n            });\n          }\n        } catch (err) {\n          // In case we get something weird in the block using 'resp'.\n          // XXX We could also just remove the try/catch if we believe\n          // the resp stuff should always work, but just in case...\n          reject(err);\n        }\n      });\n    });\n  }\n  /**\n   * Clear out local state at the beginning and if we end up\n   * getting disconnected and try to reconnect.\n   */\n\n\n  _clearLocalVars() {\n    if (this._client) {\n      this._client.removeAllListeners();\n\n      this._client.end();\n    }\n\n    this._client = null;\n    this._clientPromise = null;\n    this._wildmatch = false;\n    this._relative_root = false;\n    this._subscriptionId = 1;\n    this._watcherMap = Object.create(null); // Note that we do not clear _clientListeners or _watchmanBinaryPath.\n  }\n\n  _genSubscription() {\n    let val = 'sane_' + this._subscriptionId++;\n    return val;\n  }\n  /**\n   * Create a new watcherInfo entry for the given watchmanWatcher and\n   * initialize it.\n   */\n\n\n  _createWatcherInfo(watchmanWatcher) {\n    let watcherInfo = {\n      subscription: this._genSubscription(),\n      watchmanWatcher: watchmanWatcher,\n      root: null,\n      // set during 'watch' or 'watch-project'\n      relativePath: null,\n      // same\n      since: null,\n      // set during 'clock'\n      options: null // created and set during 'subscribe'.\n\n    };\n    this._watcherMap[watcherInfo.subscription] = watcherInfo;\n    return watcherInfo;\n  }\n  /**\n   * Find an existing watcherInfo instance.\n   */\n\n\n  _getWatcherInfo(subscription) {\n    return this._watcherMap[subscription];\n  }\n  /**\n   * Given a watchmanWatcher and a root, issue the correct 'watch'\n   * or 'watch-project' command and handle it with the callback.\n   * Because we're operating in 'sane', we'll keep the results\n   * of the 'watch' or 'watch-project' here.\n   */\n\n\n  _watch(subscription, root) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription);\n\n      if (this._relative_root) {\n        this._client.command(['watch-project', root], (error, resp) => {\n          if (error) {\n            reject(error);\n          } else {\n            watcherInfo.root = resp.watch;\n            watcherInfo.relativePath = resp.relative_path ? resp.relative_path : '';\n            resolve(resp);\n          }\n        });\n      } else {\n        this._client.command(['watch', root], (error, resp) => {\n          if (error) {\n            reject(error);\n          } else {\n            watcherInfo.root = root;\n            watcherInfo.relativePath = '';\n            resolve(resp);\n          }\n        });\n      }\n    });\n  }\n  /**\n   * Issue the 'clock' command to get the time value for use with the 'since'\n   * option during 'subscribe'.\n   */\n\n\n  _clock(subscription) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription);\n\n      this._client.command(['clock', watcherInfo.root], (error, resp) => {\n        if (error) {\n          reject(error);\n        } else {\n          watcherInfo.since = resp.clock;\n          resolve(resp);\n        }\n      });\n    });\n  }\n  /**\n   * Do the internal handling of calling the watchman.Client for\n   * a subscription.\n   */\n\n\n  _subscribe(subscription) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription); // create the 'bare' options w/o 'since' or relative_root.\n      // Store in watcherInfo for later use if we need to reset\n      // things after an 'end' caught here.\n\n\n      let options = watcherInfo.watchmanWatcher.createOptions();\n      watcherInfo.options = options; // Dup the options object so we can add 'relative_root' and 'since'\n      // and leave the original options object alone. We'll do this again\n      // later if we need to resubscribe after 'end' and reconnect.\n\n      options = Object.assign({}, options);\n\n      if (this._relative_root) {\n        options.relative_root = watcherInfo.relativePath;\n      }\n\n      options.since = watcherInfo.since;\n\n      this._client.command(['subscribe', watcherInfo.root, subscription, options], (error, resp) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(resp);\n        }\n      });\n    });\n  }\n  /**\n   * Handle the 'subscription' (file change) event, by calling the\n   * handler on the relevant WatchmanWatcher.\n   */\n\n\n  _onSubscription(resp) {\n    let watcherInfo = this._getWatcherInfo(resp.subscription);\n\n    if (watcherInfo) {\n      // we're assuming the watchmanWatcher does not throw during\n      // handling of the change event.\n      watcherInfo.watchmanWatcher.handleChangeEvent(resp);\n    } else {\n      // Note it in the log, but otherwise ignore it\n      console.error(\"WatchmanClient error - received 'subscription' event \" + \"for non-existent subscription '\" + resp.subscription + \"'\");\n    }\n  }\n  /**\n   * Handle the 'error' event by forwarding to the\n   * handler on all WatchmanWatchers (errors are generally during processing\n   * a particular command, but it's not given which command that was, or\n   * which subscription it belonged to).\n   */\n\n\n  _onError(error) {\n    values(this._watcherMap).forEach(watcherInfo => watcherInfo.watchmanWatcher.handleErrorEvent(error));\n  }\n  /**\n   * Handle the 'end' event by creating a new watchman.Client and\n   * attempting to resubscribe all the existing subscriptions, but\n   * without notifying the WatchmanWatchers about it. They should\n   * not be aware the connection was lost and recreated.\n   * If something goes wrong during any part of the reconnect/setup,\n   * call the error handler on each existing WatchmanWatcher.\n   */\n\n\n  _onEnd() {\n    console.warn('[sane.WatchmanClient] Warning: Lost connection to watchman, reconnecting..'); // Hold the old watcher map so we use it to recreate all subscriptions.\n\n    let oldWatcherInfos = values(this._watcherMap);\n\n    this._clearLocalVars();\n\n    this._setupClient().then(() => {\n      let promises = oldWatcherInfos.map(watcherInfo => this.subscribe(watcherInfo.watchmanWatcher, watcherInfo.watchmanWatcher.root));\n      Promise.all(promises).then(() => {\n        console.log('[sane.WatchmanClient]: Reconnected to watchman');\n      }, error => {\n        console.error('[sane.WatchmanClient]: Reconnected to watchman, but failed to ' + 'reestablish at least one subscription, cannot continue');\n        console.error(error);\n        oldWatcherInfos.forEach(watcherInfo => watcherInfo.watchmanWatcher.handleErrorEvent(error)); // XXX not sure whether to clear all _watcherMap instances here,\n        // but basically this client is inconsistent now, since at least one\n        // subscribe failed.\n      });\n    }, error => {\n      console.error('[sane.WatchmanClient]: Lost connection to watchman, ' + 'reconnect failed, cannot continue');\n      console.error(error);\n      oldWatcherInfos.forEach(watcherInfo => watcherInfo.watchmanWatcher.handleErrorEvent(error));\n    });\n  }\n\n}\n\nmodule.exports = {\n  /**\n   * Create/retrieve an instance of the WatchmanClient. See the header comment\n   * about the map of client instances, one per watchmanPath.\n   * Export the getInstance method by itself so the callers cannot do anything until\n   * they get a real WatchmanClient instance here.\n   */\n  getInstance(watchmanBinaryPath) {\n    let clientMap = WatchmanClient.prototype._clientMap;\n\n    if (!clientMap) {\n      clientMap = Object.create(null);\n      WatchmanClient.prototype._clientMap = clientMap;\n    }\n\n    if (watchmanBinaryPath == undefined || watchmanBinaryPath === null) {\n      watchmanBinaryPath = '';\n    }\n\n    let watchmanClient = clientMap[watchmanBinaryPath];\n\n    if (!watchmanClient) {\n      watchmanClient = new WatchmanClient(watchmanBinaryPath);\n      clientMap[watchmanBinaryPath] = watchmanClient;\n    }\n\n    return watchmanClient;\n  }\n\n};","map":{"version":3,"sources":["/home/epitech/Documents/e-commerce/client/node_modules/sane/src/watchman_client.js"],"names":["watchman","require","captureExit","values","obj","Object","keys","map","key","WatchmanClient","constructor","watchmanBinaryPath","_clearLocalVars","_watchmanBinaryPath","_backoffTimes","_setupBackoffTimes","_clientListeners","onExit","wildmatch","_wildmatch","subscribe","watchmanWatcher","root","subscription","watcherInfo","_setupClient","then","_createWatcherInfo","_watch","_clock","_subscribe","closeWatcher","watcherInfos","_watcherMap","numWatchers","length","info","_times","_next","next","val","reset","_clientPromise","Promise","resolve","reject","_handleClientAndCheck","_createClientAndCheck","value","resp","client","capabilities","_relative_root","relative_root","_client","on","_onSubscription","bind","_onError","_onEnd","error","backoffMillis","setTimeout","Client","removeAllListeners","Error","capabilityCheck","optional","err","end","_subscriptionId","create","_genSubscription","relativePath","since","options","_getWatcherInfo","command","watch","relative_path","clock","createOptions","assign","handleChangeEvent","console","forEach","handleErrorEvent","warn","oldWatcherInfos","promises","all","log","module","exports","getInstance","clientMap","prototype","_clientMap","undefined","watchmanClient"],"mappings":"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","sourcesContent":["'use strict';\n\nconst watchman = require('fb-watchman');\nconst captureExit = require('capture-exit');\n\nfunction values(obj) {\n  return Object.keys(obj).map(key => obj[key]);\n}\n\n/**\n * Constants\n */\n\n/**\n * Singleton that provides a public API for a connection to a watchman instance for 'sane'.\n * It tries to abstract/remove as much of the boilerplate processing as necessary\n * from WatchmanWatchers that use it. In particular, they have no idea whether\n * we're using 'watch-project' or 'watch', what the 'project root' is when\n * we internally use watch-project, whether a connection has been lost\n * and reestablished, etc. Also switched to doing things with promises and known-name\n * methods in WatchmanWatcher, so as much information as possible can be kept in\n * the WatchmanClient, ultimately making this the only object listening directly\n * to watchman.Client, then forwarding appropriately (via the known-name methods) to\n * the relevant WatchmanWatcher(s).\n *\n * Note: WatchmanWatcher also added a 'watchmanPath' option for use with the sane CLI.\n * Because of that, we actually need a map of watchman binary path to WatchmanClient instance.\n * That is set up in getInstance(). Once the WatchmanWatcher has a given client, it doesn't\n * change.\n *\n * @class WatchmanClient\n * @param String watchmanBinaryPath\n * @public\n */\n\nclass WatchmanClient {\n  constructor(watchmanBinaryPath) {\n    captureExit.captureExit();\n\n    // define/clear some local state. The properties will be initialized\n    // in _handleClientAndCheck(). This is also called again in _onEnd when\n    // trying to reestablish connection to watchman.\n    this._clearLocalVars();\n\n    this._watchmanBinaryPath = watchmanBinaryPath;\n\n    this._backoffTimes = this._setupBackoffTimes();\n\n    this._clientListeners = null; // direct listeners from here to watchman.Client.\n\n    // Define a handler for if somehow the Node process gets interrupted. We need to\n    // close down the watchman.Client, if we have one.\n    captureExit.onExit(() => this._clearLocalVars());\n  }\n\n  // Define 'wildmatch' property, which must be available when we call the\n  // WatchmanWatcher.createOptions() method.\n  get wildmatch() {\n    return this._wildmatch;\n  }\n\n  /**\n   * Called from WatchmanWatcher (or WatchmanClient during reconnect) to create\n   * a watcherInfo entry in our _watcherMap and issue a 'subscribe' to the\n   * watchman.Client, to be handled here.\n   */\n  subscribe(watchmanWatcher, root) {\n    let subscription;\n    let watcherInfo;\n\n    return this._setupClient()\n      .then(() => {\n        watcherInfo = this._createWatcherInfo(watchmanWatcher);\n        subscription = watcherInfo.subscription;\n        return this._watch(subscription, root);\n      })\n      .then(() => this._clock(subscription))\n      .then(() => this._subscribe(subscription));\n    // Note: callers are responsible for noting any subscription failure.\n  }\n\n  /**\n   * Remove the information about a specific WatchmanWatcher.\n   * Once done, if no watchers are left, clear the local vars,\n   * which will end the connection to the watchman.Client, too.\n   */\n  closeWatcher(watchmanWatcher) {\n    let watcherInfos = values(this._watcherMap);\n    let numWatchers = watcherInfos.length;\n\n    if (numWatchers > 0) {\n      let watcherInfo;\n\n      for (let info of watcherInfos) {\n        if (info.watchmanWatcher === watchmanWatcher) {\n          watcherInfo = info;\n          break;\n        }\n      }\n\n      if (watcherInfo) {\n        delete this._watcherMap[watcherInfo.subscription];\n\n        numWatchers--;\n\n        if (numWatchers === 0) {\n          this._clearLocalVars(); // nobody watching, so shut the watchman.Client down.\n        }\n      }\n    }\n  }\n\n  /**\n   * Simple backoff-time iterator. next() returns times in ms.\n   * When it's at the last value, it stays there until reset()\n   * is called.\n   */\n  _setupBackoffTimes() {\n    return {\n      _times: [0, 1000, 5000, 10000, 60000],\n\n      _next: 0,\n\n      next() {\n        let val = this._times[this._next];\n        if (this._next < this._times.length - 1) {\n          this._next++;\n        }\n        return val;\n      },\n\n      reset() {\n        this._next = 0;\n      },\n    };\n  }\n\n  /**\n   * Set up the connection to the watchman client. Return a promise\n   * that is fulfilled when we have a client that has finished the\n   * capabilityCheck.\n   */\n  _setupClient() {\n    if (!this._clientPromise) {\n      this._clientPromise = new Promise((resolve, reject) => {\n        this._handleClientAndCheck(resolve, reject);\n      });\n    }\n\n    return this._clientPromise;\n  }\n\n  /**\n   * Handle the process of creating a client and doing a capability check and\n   * getting a valid response, then setting up local data based on that.\n   *\n   * This is split from _setupClient and _createClientAndCheck so it can\n   * provide the backoff handling needed during attempts to reconnect.\n   */\n  _handleClientAndCheck(resolve, reject) {\n    this._createClientAndCheck().then(\n      value => {\n        let resp = value.resp;\n        let client = value.client;\n\n        try {\n          this._wildmatch = resp.capabilities.wildmatch;\n          this._relative_root = resp.capabilities.relative_root;\n          this._client = client;\n\n          client.on('subscription', this._onSubscription.bind(this));\n          client.on('error', this._onError.bind(this));\n          client.on('end', this._onEnd.bind(this));\n\n          this._backoffTimes.reset();\n          resolve(this);\n        } catch (error) {\n          // somehow, even though we supposedly got a valid value back, it's\n          // malformed, or some other internal error occurred. Reject so\n          // the promise itself doesn't hang forever.\n          reject(error);\n        }\n      },\n      () => {\n        // create & capability check failed in any of several ways,\n        // do the retry with backoff.\n\n        // XXX May want to change this later to actually reject/terminate with\n        // an error in certain of the inner errors (e.g. when we\n        // can figure out the server is definitely not coming\n        // back, or something else is not recoverable by just waiting).\n        // Could also decide after N retries to just quit.\n\n        let backoffMillis = this._backoffTimes.next();\n\n        // XXX may want to fact we'll attempt reconnect in backoffMillis ms.\n        setTimeout(() => {\n          this._handleClientAndCheck(resolve, reject);\n        }, backoffMillis);\n      }\n    );\n  }\n\n  /**\n   * Create a promise that will only be fulfilled when either\n   * we correctly get capabilities back or we get an 'error' or 'end'\n   * callback, indicating a problem. The caller _handleClientAndCheck\n   * then deals with providing a retry and backoff mechanism.\n   */\n  _createClientAndCheck() {\n    return new Promise((resolve, reject) => {\n      let client;\n\n      try {\n        client = new watchman.Client(\n          this._watchmanBinaryPath\n            ? { watchmanBinaryPath: this._watchmanBinaryPath }\n            : {}\n        );\n      } catch (error) {\n        // if we're here, either the binary path is bad or something\n        // else really bad happened. The client doesn't even attempt\n        // to connect until we send it a command, though.\n        reject(error);\n        return;\n      }\n\n      client.on('error', error => {\n        client.removeAllListeners();\n        reject(error);\n      });\n\n      client.on('end', () => {\n        client.removeAllListeners();\n        reject(new Error('Disconnected during client capabilities check'));\n      });\n\n      client.capabilityCheck(\n        { optional: ['wildmatch', 'relative_root'] },\n        (error, resp) => {\n          try {\n            client.removeAllListeners();\n\n            if (error) {\n              reject(error);\n            } else {\n              resolve({ resp, client });\n            }\n          } catch (err) {\n            // In case we get something weird in the block using 'resp'.\n            // XXX We could also just remove the try/catch if we believe\n            // the resp stuff should always work, but just in case...\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Clear out local state at the beginning and if we end up\n   * getting disconnected and try to reconnect.\n   */\n  _clearLocalVars() {\n    if (this._client) {\n      this._client.removeAllListeners();\n      this._client.end();\n    }\n\n    this._client = null;\n    this._clientPromise = null;\n    this._wildmatch = false;\n    this._relative_root = false;\n    this._subscriptionId = 1;\n    this._watcherMap = Object.create(null);\n\n    // Note that we do not clear _clientListeners or _watchmanBinaryPath.\n  }\n\n  _genSubscription() {\n    let val = 'sane_' + this._subscriptionId++;\n    return val;\n  }\n\n  /**\n   * Create a new watcherInfo entry for the given watchmanWatcher and\n   * initialize it.\n   */\n  _createWatcherInfo(watchmanWatcher) {\n    let watcherInfo = {\n      subscription: this._genSubscription(),\n      watchmanWatcher: watchmanWatcher,\n      root: null, // set during 'watch' or 'watch-project'\n      relativePath: null, // same\n      since: null, // set during 'clock'\n      options: null, // created and set during 'subscribe'.\n    };\n\n    this._watcherMap[watcherInfo.subscription] = watcherInfo;\n\n    return watcherInfo;\n  }\n\n  /**\n   * Find an existing watcherInfo instance.\n   */\n  _getWatcherInfo(subscription) {\n    return this._watcherMap[subscription];\n  }\n\n  /**\n   * Given a watchmanWatcher and a root, issue the correct 'watch'\n   * or 'watch-project' command and handle it with the callback.\n   * Because we're operating in 'sane', we'll keep the results\n   * of the 'watch' or 'watch-project' here.\n   */\n  _watch(subscription, root) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription);\n\n      if (this._relative_root) {\n        this._client.command(['watch-project', root], (error, resp) => {\n          if (error) {\n            reject(error);\n          } else {\n            watcherInfo.root = resp.watch;\n            watcherInfo.relativePath = resp.relative_path\n              ? resp.relative_path\n              : '';\n            resolve(resp);\n          }\n        });\n      } else {\n        this._client.command(['watch', root], (error, resp) => {\n          if (error) {\n            reject(error);\n          } else {\n            watcherInfo.root = root;\n            watcherInfo.relativePath = '';\n            resolve(resp);\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Issue the 'clock' command to get the time value for use with the 'since'\n   * option during 'subscribe'.\n   */\n  _clock(subscription) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription);\n\n      this._client.command(['clock', watcherInfo.root], (error, resp) => {\n        if (error) {\n          reject(error);\n        } else {\n          watcherInfo.since = resp.clock;\n          resolve(resp);\n        }\n      });\n    });\n  }\n\n  /**\n   * Do the internal handling of calling the watchman.Client for\n   * a subscription.\n   */\n  _subscribe(subscription) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription);\n\n      // create the 'bare' options w/o 'since' or relative_root.\n      // Store in watcherInfo for later use if we need to reset\n      // things after an 'end' caught here.\n      let options = watcherInfo.watchmanWatcher.createOptions();\n      watcherInfo.options = options;\n\n      // Dup the options object so we can add 'relative_root' and 'since'\n      // and leave the original options object alone. We'll do this again\n      // later if we need to resubscribe after 'end' and reconnect.\n      options = Object.assign({}, options);\n\n      if (this._relative_root) {\n        options.relative_root = watcherInfo.relativePath;\n      }\n\n      options.since = watcherInfo.since;\n\n      this._client.command(\n        ['subscribe', watcherInfo.root, subscription, options],\n        (error, resp) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(resp);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Handle the 'subscription' (file change) event, by calling the\n   * handler on the relevant WatchmanWatcher.\n   */\n  _onSubscription(resp) {\n    let watcherInfo = this._getWatcherInfo(resp.subscription);\n\n    if (watcherInfo) {\n      // we're assuming the watchmanWatcher does not throw during\n      // handling of the change event.\n      watcherInfo.watchmanWatcher.handleChangeEvent(resp);\n    } else {\n      // Note it in the log, but otherwise ignore it\n      console.error(\n        \"WatchmanClient error - received 'subscription' event \" +\n          \"for non-existent subscription '\" +\n          resp.subscription +\n          \"'\"\n      );\n    }\n  }\n\n  /**\n   * Handle the 'error' event by forwarding to the\n   * handler on all WatchmanWatchers (errors are generally during processing\n   * a particular command, but it's not given which command that was, or\n   * which subscription it belonged to).\n   */\n  _onError(error) {\n    values(this._watcherMap).forEach(watcherInfo =>\n      watcherInfo.watchmanWatcher.handleErrorEvent(error)\n    );\n  }\n\n  /**\n   * Handle the 'end' event by creating a new watchman.Client and\n   * attempting to resubscribe all the existing subscriptions, but\n   * without notifying the WatchmanWatchers about it. They should\n   * not be aware the connection was lost and recreated.\n   * If something goes wrong during any part of the reconnect/setup,\n   * call the error handler on each existing WatchmanWatcher.\n   */\n  _onEnd() {\n    console.warn(\n      '[sane.WatchmanClient] Warning: Lost connection to watchman, reconnecting..'\n    );\n\n    // Hold the old watcher map so we use it to recreate all subscriptions.\n    let oldWatcherInfos = values(this._watcherMap);\n\n    this._clearLocalVars();\n\n    this._setupClient().then(\n      () => {\n        let promises = oldWatcherInfos.map(watcherInfo =>\n          this.subscribe(\n            watcherInfo.watchmanWatcher,\n            watcherInfo.watchmanWatcher.root\n          )\n        );\n        Promise.all(promises).then(\n          () => {\n            console.log('[sane.WatchmanClient]: Reconnected to watchman');\n          },\n          error => {\n            console.error(\n              '[sane.WatchmanClient]: Reconnected to watchman, but failed to ' +\n                'reestablish at least one subscription, cannot continue'\n            );\n            console.error(error);\n            oldWatcherInfos.forEach(watcherInfo =>\n              watcherInfo.watchmanWatcher.handleErrorEvent(error)\n            );\n            // XXX not sure whether to clear all _watcherMap instances here,\n            // but basically this client is inconsistent now, since at least one\n            // subscribe failed.\n          }\n        );\n      },\n      error => {\n        console.error(\n          '[sane.WatchmanClient]: Lost connection to watchman, ' +\n            'reconnect failed, cannot continue'\n        );\n        console.error(error);\n        oldWatcherInfos.forEach(watcherInfo =>\n          watcherInfo.watchmanWatcher.handleErrorEvent(error)\n        );\n      }\n    );\n  }\n}\n\nmodule.exports = {\n  /**\n   * Create/retrieve an instance of the WatchmanClient. See the header comment\n   * about the map of client instances, one per watchmanPath.\n   * Export the getInstance method by itself so the callers cannot do anything until\n   * they get a real WatchmanClient instance here.\n   */\n  getInstance(watchmanBinaryPath) {\n    let clientMap = WatchmanClient.prototype._clientMap;\n\n    if (!clientMap) {\n      clientMap = Object.create(null);\n      WatchmanClient.prototype._clientMap = clientMap;\n    }\n\n    if (watchmanBinaryPath == undefined || watchmanBinaryPath === null) {\n      watchmanBinaryPath = '';\n    }\n\n    let watchmanClient = clientMap[watchmanBinaryPath];\n\n    if (!watchmanClient) {\n      watchmanClient = new WatchmanClient(watchmanBinaryPath);\n      clientMap[watchmanBinaryPath] = watchmanClient;\n    }\n\n    return watchmanClient;\n  },\n};\n"]},"metadata":{},"sourceType":"script"}